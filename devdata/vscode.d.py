# Generated by ts2python on 2022-09-25 22:17:05.078202


import sys
from enum import Enum, IntEnum
if sys.version_info >= (3, 9, 0):
    from typing import Union, Optional, Any, Generic, TypeVar, Callable, List, Tuple, Dict
    # do not use list, tuple, dict, because contained types won't be forward ref'd
    from collections.abc import Coroutine
else:
    from typing import Union, List, Tuple, Optional, Dict, Any, Generic, TypeVar, Callable, Coroutine


try:
    from ts2python.typeddict_shim import TypedDict, GenericTypedDict, NotRequired, Literal
    # Overwrite typing.TypedDict for Runtime-Validation
except ImportError:
    print("Module ts2python.typeddict_shim not found. Only coarse-grained "
          "runtime type-validation of TypedDicts possible")
    try:
        from typing import TypedDict, Literal
    except ImportError:
        try:
            from ts2python.typing_extensions import TypedDict, Literal
        except ImportError:
            print(f'Please install the "typing_extensions" module via the shell '
                  f'command "# pip install typing_extensions" before running '
                  f'{__file__} with Python-versions <= 3.7!')
    try:
        from typing_extensions import NotRequired
    except ImportError:
        NotRequired = Optional
    if sys.version_info >= (3, 7, 0):  GenericMeta = type
    else:
        from typing import GenericMeta
    class _GenericTypedDictMeta(GenericMeta):
        def __new__(cls, name, bases, ns, total=True):
            return type.__new__(_GenericTypedDictMeta, name, (dict,), ns)
        __call__ = dict
    GenericTypedDict = _GenericTypedDictMeta('TypedDict', (dict,), {})
    GenericTypedDict.__module__ = __name__


try:
    from ts2python.singledispatch_shim import singledispatch, singledispatchmethod
except ImportError:
    print("ts2python.singledispatch_shim not found! @singledispatch-annotation"
          " imported from functools may cause NameErrors on forward-referenced"
          " types.")
    try:
        from functools import singledispatch, singledispatchmethod
    except ImportError:
        print(f"functools.singledispatchmethod does not exist in Python Version "
              f"{sys.version}. This module may therefore fail to run if "
              f"singledispatchmethod is needed, anywhere!")


source_hash__ = "34ec60f947d23b709d2761707c515169 363ed24320e08bc6b39a21500d3f10b6"


##### BEGIN OF LSP SPECS


version: str


class Command(TypedDict, total=False):
    title: str
    command: str
    tooltip: Optional[str]
    arguments: Optional[List[Any]]


class TextLine(TypedDict, total=True):
    lineNumber: float
    text: str
    range: 'Range'
    rangeIncludingLineBreak: 'Range'
    firstNonWhitespaceCharacterIndex: float
    isEmptyOrWhitespace: bool


class TextDocument:
    uri: 'Uri'
    fileName: str
    isUntitled: bool
    languageId: str
    version: float
    isDirty: bool
    isClosed: bool

    def save(self) -> Coroutine[bool]:
        pass
    eol: 'EndOfLine'
    lineCount: float

    @singledispatchmethod
    def lineAt(self, line: float) -> TextLine:
        pass

    @lineAt.register
    def _(self, position: 'Position') -> TextLine:
        pass

    def offsetAt(self, position: 'Position') -> float:
        pass

    def positionAt(self, offset: float) -> 'Position':
        pass

    def getText(self, range: Optional['Range'] = None) -> str:
        pass

    def getWordRangeAtPosition(self, position: 'Position', regex: Optional[str] = None) -> Union['Range', None]:
        pass

    def validateRange(self, range: 'Range') -> 'Range':
        pass

    def validatePosition(self, position: 'Position') -> 'Position':
        pass


class Position:
    class TranslateChange_0(TypedDict, total=False):
        lineDelta: Optional[float]
        characterDelta: Optional[float]
    class With_Change_0(TypedDict, total=False):
        line: Optional[float]
        character: Optional[float]
    line: float
    character: float


    def isBefore(self, other: 'Position') -> bool:
        pass

    def isBeforeOrEqual(self, other: 'Position') -> bool:
        pass

    def isAfter(self, other: 'Position') -> bool:
        pass

    def isAfterOrEqual(self, other: 'Position') -> bool:
        pass

    def isEqual(self, other: 'Position') -> bool:
        pass

    def compareTo(self, other: 'Position') -> float:
        pass

    @singledispatchmethod
    def translate(self, lineDelta: Optional[float] = None, characterDelta: Optional[float] = None) -> 'Position':
        pass

    @translate.register
    def _(self, change: TranslateChange_0) -> 'Position':
        pass

    @singledispatchmethod
    def with_(self, line: Optional[float] = None, character: Optional[float] = None) -> 'Position':
        pass

    @with_.register
    def _(self, change: With_Change_0) -> 'Position':
        pass


class Range:
    class With_Change_0(TypedDict, total=False):
        start: Optional[Position]
        end: Optional[Position]
    start: Position
    end: Position


    isEmpty: bool
    isSingleLine: bool

    def contains(self, positionOrRange: Union[Position, 'Range']) -> bool:
        pass

    def isEqual(self, other: 'Range') -> bool:
        pass

    def intersection(self, range: 'Range') -> Union['Range', None]:
        pass

    def union(self, other: 'Range') -> 'Range':
        pass

    @singledispatchmethod
    def with_(self, start: Optional[Position] = None, end: Optional[Position] = None) -> 'Range':
        pass

    @with_.register
    def _(self, change: With_Change_0) -> 'Range':
        pass


class Selection(Range):
    anchor: Position
    active: Position


    isReversed: bool

class TextEditorSelectionChangeKind(IntEnum):
    Keyboard = 1
    Mouse = 2
    Command = 3


class TextEditorSelectionChangeEvent(TypedDict, total=True):
    textEditor: 'TextEditor'
    selections: List[Selection]
    kind: Union[TextEditorSelectionChangeKind, None]


class TextEditorVisibleRangesChangeEvent(TypedDict, total=True):
    textEditor: 'TextEditor'
    visibleRanges: List[Range]


class TextEditorOptionsChangeEvent(TypedDict, total=True):
    textEditor: 'TextEditor'
    options: 'TextEditorOptions'


class TextEditorViewColumnChangeEvent(TypedDict, total=True):
    textEditor: 'TextEditor'
    viewColumn: 'ViewColumn'

class TextEditorCursorStyle(IntEnum):
    Line = 1
    Block = 2
    Underline = 3
    LineThin = 4
    BlockOutline = 5
    UnderlineThin = 6

class TextEditorLineNumbersStyle(IntEnum):
    Off = 0
    On = 1
    Relative = 2


class TextEditorOptions(TypedDict, total=False):
    tabSize: Union[float, str, None]
    insertSpaces: Union[bool, str, None]
    cursorStyle: Optional[TextEditorCursorStyle]
    lineNumbers: Optional[TextEditorLineNumbersStyle]


class TextEditorDecorationType:
    key: str

    def dispose(self) -> None:
        pass

class TextEditorRevealType(IntEnum):
    Default = 0
    InCenter = 1
    InCenterIfOutsideViewport = 2
    AtTop = 3

class OverviewRulerLane(IntEnum):
    Left = 1
    Center = 2
    Right = 4
    Full = 7

class DecorationRangeBehavior(IntEnum):
    OpenOpen = 0
    ClosedClosed = 1
    OpenClosed = 2
    ClosedOpen = 3


class TextDocumentShowOptions(TypedDict, total=False):
    viewColumn: Optional['ViewColumn']
    preserveFocus: Optional[bool]
    preview: Optional[bool]
    selection: Optional[Range]


class ThemeColor:
    pass


class ThemeIcon:
    File: 'ThemeIcon'
    Folder: 'ThemeIcon'
    id: str
    color: Union[ThemeColor, None]


class ThemableDecorationRenderOptions(TypedDict, total=False):
    backgroundColor: Union[str, ThemeColor, None]
    outline: Optional[str]
    outlineColor: Union[str, ThemeColor, None]
    outlineStyle: Optional[str]
    outlineWidth: Optional[str]
    border: Optional[str]
    borderColor: Union[str, ThemeColor, None]
    borderRadius: Optional[str]
    borderSpacing: Optional[str]
    borderStyle: Optional[str]
    borderWidth: Optional[str]
    fontStyle: Optional[str]
    fontWeight: Optional[str]
    textDecoration: Optional[str]
    cursor: Optional[str]
    color: Union[str, ThemeColor, None]
    opacity: Optional[str]
    terSpacing: Optional[str]
    gutterIconPath: Union[str, 'Uri', None]
    gutterIconSize: Optional[str]
    overviewRulerColor: Union[str, ThemeColor, None]
    before: Optional['ThemableDecorationAttachmentRenderOptions']
    after: Optional['ThemableDecorationAttachmentRenderOptions']


class ThemableDecorationAttachmentRenderOptions(TypedDict, total=False):
    contentText: Optional[str]
    contentIconPath: Union[str, 'Uri', None]
    border: Optional[str]
    borderColor: Union[str, ThemeColor, None]
    fontStyle: Optional[str]
    fontWeight: Optional[str]
    textDecoration: Optional[str]
    color: Union[str, ThemeColor, None]
    backgroundColor: Union[str, ThemeColor, None]
    margin: Optional[str]
    width: Optional[str]
    height: Optional[str]


class DecorationRenderOptions(ThemableDecorationRenderOptions, TypedDict, total=False):
    isWholeLine: Optional[bool]
    rangeBehavior: Optional[DecorationRangeBehavior]
    overviewRulerLane: Optional[OverviewRulerLane]
    light: Optional[ThemableDecorationRenderOptions]
    dark: Optional[ThemableDecorationRenderOptions]


class DecorationOptions(TypedDict, total=False):
    range: Range
    hoverMessage: Union['MarkdownString', 'MarkedString', List[Union['MarkdownString', 'MarkedString']], None]
    renderOptions: Optional['DecorationInstanceRenderOptions']


class ThemableDecorationInstanceRenderOptions(TypedDict, total=False):
    before: Optional[ThemableDecorationAttachmentRenderOptions]
    after: Optional[ThemableDecorationAttachmentRenderOptions]


class DecorationInstanceRenderOptions(ThemableDecorationInstanceRenderOptions, TypedDict, total=False):
    light: Optional[ThemableDecorationInstanceRenderOptions]
    dark: Optional[ThemableDecorationInstanceRenderOptions]


class TextEditor:
    class EditOptions_0(TypedDict, total=True):
        undoStopBefore: bool
        undoStopAfter: bool
    class InsertSnippetOptions_0(TypedDict, total=True):
        undoStopBefore: bool
        undoStopAfter: bool
    document: TextDocument
    selection: Selection
    selections: List[Selection]
    visibleRanges: List[Range]
    options: TextEditorOptions
    viewColumn: Union['ViewColumn', None]

    def edit(self, callback: Callable[['TextEditorEdit'], None], options: Optional[EditOptions_0] = None) -> Coroutine[bool]:
        pass

    def insertSnippet(self, snippet: 'SnippetString', location: Optional[Union[Position, Range, List[Position], List[Range]]] = None, options: Optional[InsertSnippetOptions_0] = None) -> Coroutine[bool]:
        pass

    def setDecorations(self, decorationType: TextEditorDecorationType, rangesOrOptions: Union[List[Range], List[DecorationOptions]]) -> None:
        pass

    def revealRange(self, range: Range, revealType: Optional[TextEditorRevealType] = None) -> None:
        pass

    def show(self, column: Optional['ViewColumn'] = None) -> None:
        pass

    def hide(self) -> None:
        pass

class EndOfLine(IntEnum):
    LF = 1
    CRLF = 2


class TextEditorEdit:

    def replace(self, location: Union[Position, Range, Selection], value: str) -> None:
        pass

    def insert(self, location: Position, value: str) -> None:
        pass

    def delete(self, location: Union[Range, Selection]) -> None:
        pass

    def setEndOfLine(self, endOfLine: EndOfLine) -> None:
        pass


class Uri:
    class From_Components_0(TypedDict, total=False):
        scheme: str
        authority: Optional[str]
        path: Optional[str]
        query: Optional[str]
        fragment: Optional[str]
    class With_Change_0(TypedDict, total=False):
        scheme: Optional[str]
        authority: Optional[str]
        path: Optional[str]
        query: Optional[str]
        fragment: Optional[str]

    def parse(self, value: str, strict: Optional[bool] = None) -> 'Uri':
        pass

    def file(self, path: str) -> 'Uri':
        pass

    def joinPath(self, base: 'Uri', *pathSegments: str) -> 'Uri':
        pass

    def from_(self, components: From_Components_0) -> 'Uri':
        pass
    private: Any

    scheme: str
    authority: str
    path: str
    query: str
    fragment: str
    fsPath: str

    def with_(self, change: With_Change_0) -> 'Uri':
        pass

    def toString(self, skipEncoding: Optional[bool] = None) -> str:
        pass

    def toJSON(self) -> Any:
        pass


class CancellationToken(TypedDict, total=True):
    isCancellationRequested: bool
    onCancellationRequested: 'Event[Any]'


class CancellationTokenSource:
    token: CancellationToken

    def cancel(self) -> None:
        pass

    def dispose(self) -> None:
        pass


class CancellationError(Exception):
    pass


class Disposable:
    class From_Disposable_0(TypedDict, total=True):
        dispose: Callable[[], Any]

    def from_(self, *disposableLikes: From_Disposable_0) -> 'Disposable':
        pass


    def dispose(self) -> Any:
        pass

T = TypeVar('T')

class Event(Generic[T]):

    def __call__(self, listener: Callable[[T], Any], thisArgs: Optional[Any] = None, disposables: Optional[List[Disposable]] = None) -> Disposable:
        pass

T = TypeVar('T')

class EventEmitter(Generic[T]):
    event: Event[T]

    def fire(self, data: T) -> None:
        pass

    def dispose(self) -> None:
        pass


class FileSystemWatcher(Disposable):
    ignoreCreateEvents: bool
    ignoreChangeEvents: bool
    ignoreDeleteEvents: bool
    onDidCreate: Event[Uri]
    onDidChange: Event[Uri]
    onDidDelete: Event[Uri]


class TextDocumentContentProvider:
    onDidChange: Optional[Event[Uri]]

    def provideTextDocumentContent(self, uri: Uri, token: CancellationToken) -> 'ProviderResult[str]':
        pass

class QuickPickItemKind(IntEnum):
    Separator = -1
    Default = 0


class QuickPickItem(TypedDict, total=False):
    label: str
    kind: Optional[QuickPickItemKind]
    description: Optional[str]
    detail: Optional[str]
    picked: Optional[bool]
    alwaysShow: Optional[bool]
    buttons: Optional[List['QuickInputButton']]


class QuickPickOptions:
    title: Optional[str]
    matchOnDescription: Optional[bool]
    matchOnDetail: Optional[bool]
    placeHolder: Optional[str]
    ignoreFocusOut: Optional[bool]
    canPickMany: Optional[bool]

    def onDidSelectItem(self, item: Union[QuickPickItem, str]) -> Any:
        pass


class WorkspaceFolderPickOptions(TypedDict, total=False):
    placeHolder: Optional[str]
    ignoreFocusOut: Optional[bool]


class OpenDialogOptions(TypedDict, total=False):
    defaultUri: Optional[Uri]
    openLabel: Optional[str]
    canSelectFiles: Optional[bool]
    canSelectFolders: Optional[bool]
    canSelectMany: Optional[bool]
    filters: Optional[Dict[str, List[str]]]
    title: Optional[str]


class SaveDialogOptions(TypedDict, total=False):
    defaultUri: Optional[Uri]
    saveLabel: Optional[str]
    filters: Optional[Dict[str, List[str]]]
    title: Optional[str]


class MessageItem(TypedDict, total=False):
    title: str
    isCloseAffordance: Optional[bool]


class MessageOptions(TypedDict, total=False):
    modal: Optional[bool]
    detail: Optional[str]


class InputBoxOptions:
    title: Optional[str]
    value: Optional[str]
    valueSelection: Optional[Tuple[float, float]]
    prompt: Optional[str]
    placeHolder: Optional[str]
    password: Optional[bool]
    ignoreFocusOut: Optional[bool]

    def validateInput(self, value: str) -> Union[str, None, Coroutine[Union[str, None]]]:
        pass


class RelativePattern:
    baseUri: Uri
    base: str
    pattern: str


GlobPattern = Union[str, RelativePattern]


class DocumentFilter(TypedDict, total=False):
    language: Optional[str]
    scheme: Optional[str]
    pattern: Optional[GlobPattern]

DocumentSelector = Union[DocumentFilter, str, List[Union[DocumentFilter, str]]]

ProviderResult = Union[T, None, Coroutine[Union[T, None]]]


class CodeActionKind:
    Empty: 'CodeActionKind'
    QuickFix: 'CodeActionKind'
    Refactor: 'CodeActionKind'
    RefactorExtract: 'CodeActionKind'
    RefactorInline: 'CodeActionKind'
    RefactorRewrite: 'CodeActionKind'
    Source: 'CodeActionKind'
    SourceOrganizeImports: 'CodeActionKind'
    SourceFixAll: 'CodeActionKind'
    private: Any

    value: str

    def append(self, parts: str) -> 'CodeActionKind':
        pass

    def intersects(self, other: 'CodeActionKind') -> bool:
        pass

    def contains(self, other: 'CodeActionKind') -> bool:
        pass

class CodeActionTriggerKind(IntEnum):
    Invoke = 1
    Automatic = 2


class CodeActionContext(TypedDict, total=True):
    triggerKind: CodeActionTriggerKind
    diagnostics: List['Diagnostic']
    only: Union[CodeActionKind, None]


class CodeAction:
    class Disabled_0(TypedDict, total=True):
        reason: str
    title: str
    edit: Optional['WorkspaceEdit']
    diagnostics: Optional[List['Diagnostic']]
    command: Optional[Command]
    kind: Optional[CodeActionKind]
    isPreferred: Optional[bool]
    disabled: Optional[Disabled_0]


T = TypeVar('T')

class CodeActionProvider(Generic[T]):

    def provideCodeActions(self, document: TextDocument, range: Union[Range, Selection], context: CodeActionContext, token: CancellationToken) -> ProviderResult[List[Union[Command, T]]]:
        pass

    def resolveCodeAction(self, codeAction: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class CodeActionProviderMetadata(TypedDict, total=False):
    class Documentation_0(TypedDict, total=True):
        kind: CodeActionKind
        command: Command
    providedCodeActionKinds: Optional[List[CodeActionKind]]
    documentation: Optional[List[Documentation_0]]


class CodeLens:
    range: Range
    command: Optional[Command]
    isResolved: bool


T = TypeVar('T')

class CodeLensProvider(Generic[T]):
    onDidChangeCodeLenses: Optional[Event]

    def provideCodeLenses(self, document: TextDocument, token: CancellationToken) -> ProviderResult[List[T]]:
        pass

    def resolveCodeLens(self, codeLens: T, token: CancellationToken) -> ProviderResult[T]:
        pass

DefinitionLink = 'LocationLink'

Definition = Union['Location', List['Location']]


class DefinitionProvider:

    def provideDefinition(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[Definition, List[DefinitionLink]]]:
        pass


class ImplementationProvider:

    def provideImplementation(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[Definition, List[DefinitionLink]]]:
        pass


class TypeDefinitionProvider:

    def provideTypeDefinition(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[Definition, List[DefinitionLink]]]:
        pass

Declaration = Union['Location', List['Location'], List['LocationLink']]


class DeclarationProvider:

    def provideDeclaration(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Declaration]:
        pass


class MarkdownString:
    value: str
    isTrusted: Optional[bool]
    supportThemeIcons: Optional[bool]
    supportHtml: Optional[bool]


    def appendText(self, value: str) -> 'MarkdownString':
        pass

    def appendMarkdown(self, value: str) -> 'MarkdownString':
        pass

    def appendCodeblock(self, value: str, language: Optional[str] = None) -> 'MarkdownString':
        pass

class MarkedString_1(TypedDict, total=True):
    language: str
    value: str
MarkedString = Union[str, MarkedString_1]


class Hover:
    contents: List[Union[MarkdownString, MarkedString]]
    range: Optional[Range]


class HoverProvider:

    def provideHover(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Hover]:
        pass


class EvaluatableExpression:
    range: Range
    expression: Union[str, None]


class EvaluatableExpressionProvider:

    def provideEvaluatableExpression(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[EvaluatableExpression]:
        pass


class InlineValueText:
    range: Range
    text: str


class InlineValueVariableLookup:
    range: Range
    iableName: Union[str, None]
    caseSensitiveLookup: bool


class InlineValueEvaluatableExpression:
    range: Range
    expression: Union[str, None]


InlineValue = Union[InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression]


class InlineValueContext(TypedDict, total=True):
    frameId: float
    stoppedLocation: Range


class InlineValuesProvider:
    onDidChangeInlineValues: Union[Event, None]

    def provideInlineValues(self, document: TextDocument, viewPort: Range, context: InlineValueContext, token: CancellationToken) -> ProviderResult[List[InlineValue]]:
        pass

class DocumentHighlightKind(IntEnum):
    Text = 0
    Read = 1
    Write = 2


class DocumentHighlight:
    range: Range
    kind: Optional[DocumentHighlightKind]


class DocumentHighlightProvider:

    def provideDocumentHighlights(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[List[DocumentHighlight]]:
        pass

class SymbolKind(IntEnum):
    File = 0
    Module = 1
    Namespace = 2
    Package = 3
    Class = 4
    Method = 5
    Property = 6
    Field = 7
    Constructor = 8
    Enum = 9
    Interface = 10
    Function = 11
    Variable = 12
    Constant = 13
    String = 14
    Number = 15
    Boolean = 16
    Array = 17
    Object = 18
    Key = 19
    Null = 20
    EnumMember = 21
    Struct = 22
    Event = 23
    Operator = 24
    TypeParameter = 25

class SymbolTag(IntEnum):
    Deprecated = 1


class SymbolInformation:
    name: str
    containerName: str
    kind: SymbolKind
    tags: Optional[List[SymbolTag]]
    location: 'Location'


class DocumentSymbol:
    name: str
    detail: str
    kind: SymbolKind
    tags: Optional[List[SymbolTag]]
    range: Range
    selectionRange: Range
    children: List['DocumentSymbol']


class DocumentSymbolProvider:

    def provideDocumentSymbols(self, document: TextDocument, token: CancellationToken) -> ProviderResult[Union[List[SymbolInformation], List[DocumentSymbol]]]:
        pass


class DocumentSymbolProviderMetadata(TypedDict, total=False):
    label: Optional[str]

T = TypeVar('T')

class WorkspaceSymbolProvider(Generic[T]):

    def provideWorkspaceSymbols(self, query: str, token: CancellationToken) -> ProviderResult[List[T]]:
        pass

    def resolveWorkspaceSymbol(self, symbol: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class ReferenceContext(TypedDict, total=True):
    includeDeclaration: bool


class ReferenceProvider:

    def provideReferences(self, document: TextDocument, position: Position, context: ReferenceContext, token: CancellationToken) -> ProviderResult[List['Location']]:
        pass


class TextEdit:

    def replace(self, range: Range, newText: str) -> 'TextEdit':
        pass

    def insert(self, position: Position, newText: str) -> 'TextEdit':
        pass

    def delete(self, range: Range) -> 'TextEdit':
        pass

    def setEndOfLine(self, eol: EndOfLine) -> 'TextEdit':
        pass
    range: Range
    newText: str
    newEol: Optional[EndOfLine]


class WorkspaceEditEntryMetadata(TypedDict, total=False):
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    needsConfirmation: bool
    label: str
    description: Optional[str]
    iconPath: Union[Uri, IconPath_1, ThemeIcon, None]


class WorkspaceEdit:
    class CreateFileOptions_0(TypedDict, total=False):
        overwrite: Optional[bool]
        ignoreIfExists: Optional[bool]
    class DeleteFileOptions_0(TypedDict, total=False):
        recursive: Optional[bool]
        ignoreIfNotExists: Optional[bool]
    class RenameFileOptions_0(TypedDict, total=False):
        overwrite: Optional[bool]
        ignoreIfExists: Optional[bool]
    size: float

    def replace(self, uri: Uri, range: Range, newText: str, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass

    def insert(self, uri: Uri, position: Position, newText: str, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass

    def delete(self, uri: Uri, range: Range, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass

    def has(self, uri: Uri) -> bool:
        pass

    def set(self, uri: Uri, edits: List[TextEdit]) -> None:
        pass

    def get(self, uri: Uri) -> List[TextEdit]:
        pass

    def createFile(self, uri: Uri, options: Optional[CreateFileOptions_0] = None, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass

    def deleteFile(self, uri: Uri, options: Optional[DeleteFileOptions_0] = None, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass

    def renameFile(self, oldUri: Uri, newUri: Uri, options: Optional[RenameFileOptions_0] = None, metadata: Optional[WorkspaceEditEntryMetadata] = None) -> None:
        pass

    def entries(self) -> List[Tuple[Uri, List[TextEdit]]]:
        pass


class SnippetString:
    value: str


    def appendText(self, string: str) -> 'SnippetString':
        pass

    def appendTabstop(self, number: Optional[float] = None) -> 'SnippetString':
        pass

    def appendPlaceholder(self, value: Union[str, Callable[['SnippetString'], Any]], number: Optional[float] = None) -> 'SnippetString':
        pass

    def appendChoice(self, values: List[str], number: Optional[float] = None) -> 'SnippetString':
        pass

    def appendVariable(self, name: str, defaultValue: Union[str, Callable[['SnippetString'], Any]]) -> 'SnippetString':
        pass


class RenameProvider:
    class PrepareRenamePrepareRenameRenameProvider_1(TypedDict, total=True):
        range: Range
        placeholder: str

    def provideRenameEdits(self, document: TextDocument, position: Position, newName: str, token: CancellationToken) -> ProviderResult[WorkspaceEdit]:
        pass

    def prepareRename(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[Range, PrepareRenamePrepareRenameRenameProvider_1]]:
        pass


class SemanticTokensLegend:
    tokenTypes: List[str]
    tokenModifiers: List[str]


class SemanticTokensBuilder:


    @singledispatchmethod
    def push(self, line: float, char: float, length: float, tokenType: float, tokenModifiers: Optional[float] = None) -> None:
        pass

    @push.register
    def _(self, range: Range, tokenType: str, tokenModifiers: Optional[List[str]] = None) -> None:
        pass

    def build(self, resultId: Optional[str] = None) -> 'SemanticTokens':
        pass


class SemanticTokens:
    resultId: Union[str, None]
    data: List[int]


class SemanticTokensEdits:
    resultId: Union[str, None]
    edits: List['SemanticTokensEdit']


class SemanticTokensEdit:
    start: float
    deleteCount: float
    data: Union[List[int], None]


class DocumentSemanticTokensProvider:
    onDidChangeSemanticTokens: Optional[Event]

    def provideDocumentSemanticTokens(self, document: TextDocument, token: CancellationToken) -> ProviderResult[SemanticTokens]:
        pass

    def provideDocumentSemanticTokensEdits(self, document: TextDocument, previousResultId: str, token: CancellationToken) -> ProviderResult[Union[SemanticTokens, SemanticTokensEdits]]:
        pass


class DocumentRangeSemanticTokensProvider:

    def provideDocumentRangeSemanticTokens(self, document: TextDocument, range: Range, token: CancellationToken) -> ProviderResult[SemanticTokens]:
        pass


class FormattingOptions(TypedDict, total=True):
    tabSize: float
    insertSpaces: bool


class DocumentFormattingEditProvider:

    def provideDocumentFormattingEdits(self, document: TextDocument, options: FormattingOptions, token: CancellationToken) -> ProviderResult[List[TextEdit]]:
        pass


class DocumentRangeFormattingEditProvider:

    def provideDocumentRangeFormattingEdits(self, document: TextDocument, range: Range, options: FormattingOptions, token: CancellationToken) -> ProviderResult[List[TextEdit]]:
        pass


class OnTypeFormattingEditProvider:

    def provideOnTypeFormattingEdits(self, document: TextDocument, position: Position, ch: str, options: FormattingOptions, token: CancellationToken) -> ProviderResult[List[TextEdit]]:
        pass


class ParameterInformation:
    label: Union[str, Tuple[float, float]]
    documentation: Union[str, MarkdownString, None]


class SignatureInformation:
    label: str
    documentation: Union[str, MarkdownString, None]
    parameters: List[ParameterInformation]
    activeParameter: Optional[float]


class SignatureHelp(TypedDict, total=True):
    signatures: List[SignatureInformation]
    activeSignature: float
    activeParameter: float

class SignatureHelpTriggerKind(IntEnum):
    Invoke = 1
    TriggerCharacter = 2
    ContentChange = 3


class SignatureHelpContext(TypedDict, total=True):
    triggerKind: SignatureHelpTriggerKind
    triggerCharacter: Union[str, None]
    isRetrigger: bool
    activeSignatureHelp: Union[SignatureHelp, None]


class SignatureHelpProvider:

    def provideSignatureHelp(self, document: TextDocument, position: Position, token: CancellationToken, context: SignatureHelpContext) -> ProviderResult[SignatureHelp]:
        pass


class SignatureHelpProviderMetadata(TypedDict, total=True):
    triggerCharacters: List[str]
    retriggerCharacters: List[str]


class CompletionItemLabel(TypedDict, total=False):
    label: str
    detail: Optional[str]
    description: Optional[str]

class CompletionItemKind(IntEnum):
    Text = 0
    Method = 1
    Function = 2
    Constructor = 3
    Field = 4
    Variable = 5
    Class = 6
    Interface = 7
    Module = 8
    Property = 9
    Unit = 10
    Value = 11
    Enum = 12
    Keyword = 13
    Snippet = 14
    Color = 15
    Reference = 17
    File = 16
    Folder = 18
    EnumMember = 19
    Constant = 20
    Struct = 21
    Event = 22
    Operator = 23
    TypeParameter = 24
    User = 25
    Issue = 26

class CompletionItemTag(IntEnum):
    Deprecated = 1


class CompletionItem:
    class Range_1(TypedDict, total=True):
        inserting: Range
        replacing: Range
    label: Union[str, CompletionItemLabel]
    kind: Optional[CompletionItemKind]
    tags: Optional[List[CompletionItemTag]]
    detail: Optional[str]
    documentation: Union[str, MarkdownString, None]
    sortText: Optional[str]
    filterText: Optional[str]
    preselect: Optional[bool]
    insertText: Union[str, SnippetString, None]
    range: Union[Range, Range_1, None]
    commitCharacters: Optional[List[str]]
    keepWhitespace: Optional[bool]
    textEdit: Optional[TextEdit]
    additionalTextEdits: Optional[List[TextEdit]]
    command: Optional[Command]


T = TypeVar('T')

class CompletionList(Generic[T]):
    isIncomplete: Optional[bool]
    items: List[T]


class CompletionTriggerKind(IntEnum):
    Invoke = 0
    TriggerCharacter = 1
    TriggerForIncompleteCompletions = 2


class CompletionContext(TypedDict, total=True):
    triggerKind: CompletionTriggerKind
    triggerCharacter: Union[str, None]

T = TypeVar('T')

class CompletionItemProvider(Generic[T]):

    def provideCompletionItems(self, document: TextDocument, position: Position, token: CancellationToken, context: CompletionContext) -> ProviderResult[Union[List[T], CompletionList[T]]]:
        pass

    def resolveCompletionItem(self, item: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class DocumentLink:
    range: Range
    target: Optional[Uri]
    tooltip: Optional[str]


T = TypeVar('T')

class DocumentLinkProvider(Generic[T]):

    def provideDocumentLinks(self, document: TextDocument, token: CancellationToken) -> ProviderResult[List[T]]:
        pass

    def resolveDocumentLink(self, link: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class Color:
    red: float
    green: float
    blue: float
    alpha: float


class ColorInformation:
    range: Range
    color: Color


class ColorPresentation:
    label: str
    textEdit: Optional[TextEdit]
    additionalTextEdits: Optional[List[TextEdit]]


class DocumentColorProvider:
    class ProvideColorPresentationsContext_0(TypedDict, total=True):
        document: TextDocument
        range: Range

    def provideDocumentColors(self, document: TextDocument, token: CancellationToken) -> ProviderResult[List[ColorInformation]]:
        pass

    def provideColorPresentations(self, color: Color, context: ProvideColorPresentationsContext_0, token: CancellationToken) -> ProviderResult[List[ColorPresentation]]:
        pass

class InlayHintKind(IntEnum):
    Type = 1
    Parameter = 2


class InlayHintLabelPart:
    value: str
    tooltip: Union[str, MarkdownString, None]
    location: Union['Location', None]
    command: Union[Command, None]


class InlayHint:
    position: Position
    label: Union[str, List[InlayHintLabelPart]]
    tooltip: Union[str, MarkdownString, None]
    command: Optional[Command]
    kind: Optional[InlayHintKind]
    paddingLeft: Optional[bool]
    paddingRight: Optional[bool]


T = TypeVar('T')

class InlayHintsProvider(Generic[T]):
    onDidChangeInlayHints: Optional[Event]

    def provideInlayHints(self, document: TextDocument, range: Range, token: CancellationToken) -> ProviderResult[List[T]]:
        pass

    def resolveInlayHint(self, hint: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class FoldingRange:
    start: float
    end: float
    kind: Optional['FoldingRangeKind']


class FoldingRangeKind(IntEnum):
    Comment = 1
    Imports = 2
    Region = 3


class FoldingContext(TypedDict, total=True):
    pass


class FoldingRangeProvider:
    onDidChangeFoldingRanges: Optional[Event]

    def provideFoldingRanges(self, document: TextDocument, context: FoldingContext, token: CancellationToken) -> ProviderResult[List[FoldingRange]]:
        pass


class SelectionRange:
    range: Range
    parent: Optional['SelectionRange']


class SelectionRangeProvider:

    def provideSelectionRanges(self, document: TextDocument, positions: List[Position], token: CancellationToken) -> ProviderResult[List[SelectionRange]]:
        pass


class CallHierarchyItem:
    name: str
    kind: SymbolKind
    tags: Optional[List[SymbolTag]]
    detail: Optional[str]
    uri: Uri
    range: Range
    selectionRange: Range


class CallHierarchyIncomingCall:
    from_: CallHierarchyItem
    fromRanges: List[Range]


class CallHierarchyOutgoingCall:
    to: CallHierarchyItem
    fromRanges: List[Range]


class CallHierarchyProvider:

    def prepareCallHierarchy(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[CallHierarchyItem, List[CallHierarchyItem]]]:
        pass

    def provideCallHierarchyIncomingCalls(self, item: CallHierarchyItem, token: CancellationToken) -> ProviderResult[List[CallHierarchyIncomingCall]]:
        pass

    def provideCallHierarchyOutgoingCalls(self, item: CallHierarchyItem, token: CancellationToken) -> ProviderResult[List[CallHierarchyOutgoingCall]]:
        pass


class TypeHierarchyItem:
    name: str
    kind: SymbolKind
    tags: Optional[List[SymbolTag]]
    detail: Optional[str]
    uri: Uri
    range: Range
    selectionRange: Range


class TypeHierarchyProvider:

    def prepareTypeHierarchy(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[Union[TypeHierarchyItem, List[TypeHierarchyItem]]]:
        pass

    def provideTypeHierarchySupertypes(self, item: TypeHierarchyItem, token: CancellationToken) -> ProviderResult[List[TypeHierarchyItem]]:
        pass

    def provideTypeHierarchySubtypes(self, item: TypeHierarchyItem, token: CancellationToken) -> ProviderResult[List[TypeHierarchyItem]]:
        pass


class LinkedEditingRanges:

    ranges: List[Range]
    wordPattern: Union[str, None]


class LinkedEditingRangeProvider:

    def provideLinkedEditingRanges(self, document: TextDocument, position: Position, token: CancellationToken) -> ProviderResult[LinkedEditingRanges]:
        pass

CharacterPair = Tuple[str, str]


class CommentRule(TypedDict, total=False):
    lineComment: Optional[str]
    blockComment: Optional[CharacterPair]


class IndentationRule(TypedDict, total=False):
    decreaseIndentPattern: str
    increaseIndentPattern: str
    indentNextLinePattern: Optional[str]
    unIndentedLinePattern: Optional[str]

class IndentAction(IntEnum):
    None_ = 0
    Indent = 1
    IndentOutdent = 2
    Outdent = 3


class EnterAction(TypedDict, total=False):
    indentAction: IndentAction
    appendText: Optional[str]
    removeText: Optional[float]


class OnEnterRule(TypedDict, total=False):
    beforeText: str
    afterText: Optional[str]
    previousLineText: Optional[str]
    action: EnterAction


class LanguageConfiguration(TypedDict, total=False):
    class __electricCharacterSupport_0(TypedDict, total=False):
        class DocComment_0(TypedDict, total=False):
            scope: str
            open: str
            lineStart: str
            close: Optional[str]
        brackets: Optional[Any]
        docComment: Optional[DocComment_0]
    class __characterPairSupport_0(TypedDict, total=True):
        class AutoClosingPairs_0(TypedDict, total=False):
            open: str
            close: str
            notIn: Optional[List[str]]
        autoClosingPairs: List[AutoClosingPairs_0]
    comments: Optional[CommentRule]
    brackets: Optional[List[CharacterPair]]
    wordPattern: Optional[str]
    indentationRules: Optional[IndentationRule]
    onEnterRules: Optional[List[OnEnterRule]]
    __electricCharacterSupport: Optional[__electricCharacterSupport_0]
    __characterPairSupport: Optional[__characterPairSupport_0]

class ConfigurationTarget(IntEnum):
    Global = 1
    Workspace = 2
    WorkspaceFolder = 3


class WorkspaceConfiguration:
    class InspectWorkspaceConfiguration_0(TypedDict, total=False):
        key: str
        defaultValue: Optional[T]
        globalValue: Optional[T]
        workspaceValue: Optional[T]
        workspaceFolderValue: Optional[T]
        defaultLanguageValue: Optional[T]
        globalLanguageValue: Optional[T]
        workspaceLanguageValue: Optional[T]
        workspaceFolderLanguageValue: Optional[T]
        languageIds: Optional[List[str]]
    T = TypeVar('T')

    @singledispatchmethod
    def get(self, section: str) -> Union[T, None]:
        pass
    T = TypeVar('T')

    @get.register
    def _(self, section: str, defaultValue: T) -> T:
        pass

    def has(self, section: str) -> bool:
        pass
    T = TypeVar('T')

    def inspect(self, section: str) -> Union[InspectWorkspaceConfiguration_0, None]:
        pass

    def update(self, section: str, value: Any, configurationTarget: Optional[Union[ConfigurationTarget, bool, None]] = None, overrideInLanguage: Optional[bool] = None) -> Coroutine:
        pass


class Location:
    uri: Uri
    range: Range


class LocationLink(TypedDict, total=False):
    originSelectionRange: Optional[Range]
    targetUri: Uri
    targetRange: Range
    targetSelectionRange: Optional[Range]


class DiagnosticChangeEvent(TypedDict, total=True):
    uris: List[Uri]

class DiagnosticSeverity(IntEnum):
    Error = 0
    Warning = 1
    Information = 2
    Hint = 3


class DiagnosticRelatedInformation:
    location: Location
    message: str


class DiagnosticTag(IntEnum):
    Unnecessary = 1
    Deprecated = 2


class Diagnostic:
    class Code_2(TypedDict, total=True):
        value: Union[str, float]
        target: Uri
    range: Range
    message: str
    severity: DiagnosticSeverity
    source: Optional[str]
    code: Union[str, float, Code_2, None]
    relatedInformation: Optional[List[DiagnosticRelatedInformation]]
    tags: Optional[List[DiagnosticTag]]


class DiagnosticCollection:
    name: str

    @singledispatchmethod
    def set(self, uri: Uri, diagnostics: Union[List[Diagnostic], None]) -> None:
        pass

    @set.register
    def _(self, entries: List[Tuple[Uri, Union[List[Diagnostic], None]]]) -> None:
        pass

    def delete(self, uri: Uri) -> None:
        pass

    def clear(self) -> None:
        pass

    def forEach(self, callback: Callable[[Uri, List[Diagnostic], 'DiagnosticCollection'], Any], thisArg: Optional[Any] = None) -> None:
        pass

    def get(self, uri: Uri) -> Union[List[Diagnostic], None]:
        pass

    def has(self, uri: Uri) -> bool:
        pass

    def dispose(self) -> None:
        pass

class LanguageStatusSeverity(IntEnum):
    Information = 0
    Warning = 1
    Error = 2


class LanguageStatusItem:
    id: str
    name: Union[str, None]
    selector: DocumentSelector
    severity: LanguageStatusSeverity
    text: str
    detail: Optional[str]
    busy: bool
    command: Union[Command, None]
    accessibilityInformation: Optional['AccessibilityInformation']

    def dispose(self) -> None:
        pass

class ViewColumn(IntEnum):
    Active = -1
    Beside = -2
    One = 1
    Two = 2
    Three = 3
    Four = 4
    Five = 5
    Six = 6
    Seven = 7
    Eight = 8
    Nine = 9


class OutputChannel:
    name: str

    def append(self, value: str) -> None:
        pass

    def appendLine(self, value: str) -> None:
        pass

    def replace(self, value: str) -> None:
        pass

    def clear(self) -> None:
        pass

    @singledispatchmethod
    def show(self, preserveFocus: Optional[bool] = None) -> None:
        pass

    @show.register
    def _(self, column: Optional[ViewColumn] = None, preserveFocus: Optional[bool] = None) -> None:
        pass

    def hide(self) -> None:
        pass

    def dispose(self) -> None:
        pass


class AccessibilityInformation(TypedDict, total=False):
    label: str
    role: Optional[str]

class StatusBarAlignment(IntEnum):
    Left = 1
    Right = 2


class StatusBarItem:
    id: str
    alignment: StatusBarAlignment
    priority: Union[float, None]
    name: Union[str, None]
    text: str
    tooltip: Union[str, MarkdownString, None]
    color: Union[str, ThemeColor, None]
    backgroundColor: Union[ThemeColor, None]
    command: Union[str, Command, None]
    accessibilityInformation: Union[AccessibilityInformation, None]

    def show(self) -> None:
        pass

    def hide(self) -> None:
        pass

    def dispose(self) -> None:
        pass

T = TypeVar('T')

class Progress(Generic[T]):

    def report(self, value: T) -> None:
        pass


class Terminal:
    name: str
    processId: Coroutine[Union[float, None]]
    creationOptions: 'Readonly[Union[TerminalOptions, ExtensionTerminalOptions]]'
    exitStatus: Union['TerminalExitStatus', None]
    state: 'TerminalState'

    def sendText(self, text: str, addNewLine: Optional[bool] = None) -> None:
        pass

    def show(self, preserveFocus: Optional[bool] = None) -> None:
        pass

    def hide(self) -> None:
        pass

    def dispose(self) -> None:
        pass

class TerminalLocation(IntEnum):
    Panel = 1
    Editor = 2


class TerminalEditorLocationOptions(TypedDict, total=False):
    viewColumn: ViewColumn
    preserveFocus: Optional[bool]


class TerminalSplitLocationOptions(TypedDict, total=True):
    parentTerminal: Terminal


class TerminalState(TypedDict, total=True):
    isInteractedWith: bool


class TerminalLinkContext(TypedDict, total=True):
    line: str
    terminal: Terminal

T = TypeVar('T')

class TerminalLinkProvider(Generic[T]):

    def provideTerminalLinks(self, context: TerminalLinkContext, token: CancellationToken) -> ProviderResult[List[T]]:
        pass

    def handleTerminalLink(self, link: T) -> ProviderResult:
        pass


class TerminalLink:
    startIndex: float
    length: float
    tooltip: Optional[str]


class TerminalProfileProvider:

    def provideTerminalProfile(self, token: CancellationToken) -> ProviderResult['TerminalProfile']:
        pass


class TerminalProfile:
    options: Union['TerminalOptions', 'ExtensionTerminalOptions']


class FileDecoration:
    badge: Optional[str]
    tooltip: Optional[str]
    color: Optional[ThemeColor]
    propagate: Optional[bool]


class FileDecorationProvider:
    onDidChangeFileDecorations: Optional[Event[Union[None, Uri, List[Uri]]]]

    def provideFileDecoration(self, uri: Uri, token: CancellationToken) -> ProviderResult[FileDecoration]:
        pass

class ExtensionKind(IntEnum):
    UI = 1
    Workspace = 2

T = TypeVar('T')

class Extension(Generic[T]):
    id: str
    extensionUri: Uri
    extensionPath: str
    isActive: bool
    packageJSON: Any
    extensionKind: ExtensionKind
    exports: T

    def activate(self) -> Coroutine[T]:
        pass

class ExtensionMode(IntEnum):
    Production = 1
    Development = 2
    Test = 3


class ExtensionContext:
    class Subscriptions(TypedDict, total=True):

        def dispose(self) -> Any:
            pass
    subscriptions: List[Subscriptions]
    workspaceState: 'Memento'
    globalState: Any
    secrets: 'SecretStorage'
    extensionUri: Uri
    extensionPath: str
    environmentVariableCollection: 'EnvironmentVariableCollection'

    def asAbsolutePath(self, relativePath: str) -> str:
        pass
    storageUri: Union[Uri, None]
    storagePath: Union[str, None]
    globalStorageUri: Uri
    globalStoragePath: str
    logUri: Uri
    logPath: str
    extensionMode: ExtensionMode
    extension: Extension[Any]


class Memento:

    def keys(self) -> List[str]:
        pass
    T = TypeVar('T')

    @singledispatchmethod
    def get(self, key: str) -> Union[T, None]:
        pass
    T = TypeVar('T')

    @get.register
    def _(self, key: str, defaultValue: T) -> T:
        pass

    def update(self, key: str, value: Any) -> Coroutine:
        pass


class SecretStorageChangeEvent(TypedDict, total=True):
    key: str


class SecretStorage:

    def get(self, key: str) -> Coroutine[Union[str, None]]:
        pass

    def store(self, key: str, value: str) -> Coroutine:
        pass

    def delete(self, key: str) -> Coroutine:
        pass
    onDidChange: Event[SecretStorageChangeEvent]

class ColorThemeKind(IntEnum):
    Light = 1
    Dark = 2
    HighContrast = 3


class ColorTheme(TypedDict, total=True):
    kind: ColorThemeKind

class TaskRevealKind(IntEnum):
    Always = 1
    Silent = 2
    Never = 3

class TaskPanelKind(IntEnum):
    Shared = 1
    Dedicated = 2
    New = 3


class TaskPresentationOptions(TypedDict, total=False):
    reveal: Optional[TaskRevealKind]
    echo: Optional[bool]
    focus: Optional[bool]
    panel: Optional[TaskPanelKind]
    showReuseMessage: Optional[bool]
    clear: Optional[bool]


class TaskGroup:
    Clean: 'TaskGroup'
    Build: 'TaskGroup'
    Rebuild: 'TaskGroup'
    Test: 'TaskGroup'
    isDefault: Union[bool, None]
    id: str
    private: Any


class TaskDefinition(TypedDict, total=True):
    type: str


class ProcessExecutionOptions(TypedDict, total=False):
    cwd: Optional[str]
    env: Optional[Dict[str, str]]


class ProcessExecution:


    process: str
    args: List[str]
    options: Optional[ProcessExecutionOptions]


class ShellQuotingOptions(TypedDict, total=False):
    class Escape_1(TypedDict, total=True):
        escapeChar: str
        charsToEscape: str
    escape: Union[str, Escape_1, None]
    strong: Optional[str]
    weak: Optional[str]


class ShellExecutionOptions(TypedDict, total=False):
    executable: Optional[str]
    shellArgs: Optional[List[str]]
    shellQuoting: Optional[ShellQuotingOptions]
    cwd: Optional[str]
    env: Optional[Dict[str, str]]

class ShellQuoting(IntEnum):
    Escape = 1
    Strong = 2
    Weak = 3


class ShellQuotedString(TypedDict, total=True):
    value: str
    quoting: ShellQuoting


class ShellExecution:


    commandLine: Union[str, None]
    command: Union[str, ShellQuotedString]
    args: List[Union[str, ShellQuotedString]]
    options: Optional[ShellExecutionOptions]


class CustomExecution:
    pass

class TaskScope(IntEnum):
    Global = 1
    Workspace = 2


class RunOptions(TypedDict, total=False):
    reevaluateOnRerun: Optional[bool]


class Task:


    definition: TaskDefinition
    scope: Union['TaskScope.Global', 'TaskScope.Workspace', 'WorkspaceFolder', None]
    name: str
    detail: Optional[str]
    execution: Union[ProcessExecution, ShellExecution, CustomExecution, None]
    isBackground: bool
    source: str
    group: Optional[TaskGroup]
    presentationOptions: TaskPresentationOptions
    problemMatchers: List[str]
    runOptions: RunOptions

T = TypeVar('T')

class TaskProvider(Generic[T]):

    def provideTasks(self, token: CancellationToken) -> ProviderResult[List[T]]:
        pass

    def resolveTask(self, task: T, token: CancellationToken) -> ProviderResult[T]:
        pass


class TaskExecution:
    task: Task

    def terminate(self) -> None:
        pass


class TaskStartEvent(TypedDict, total=True):
    execution: TaskExecution


class TaskEndEvent(TypedDict, total=True):
    execution: TaskExecution


class TaskProcessStartEvent(TypedDict, total=True):
    execution: TaskExecution
    processId: float


class TaskProcessEndEvent(TypedDict, total=True):
    execution: TaskExecution
    exitCode: Union[float, None]


class TaskFilter(TypedDict, total=False):
    version: Optional[str]
    type: Optional[str]

class tasks:
    def registerTaskProvider(type: str, provider: TaskProvider) -> Disposable:
        pass

    def fetchTasks(filter: Optional[TaskFilter] = None) -> Coroutine[List[Task]]:
        pass

    def executeTask(task: Task) -> Coroutine[TaskExecution]:
        pass
    taskExecutions: List[TaskExecution]
    onDidStartTask: Event[TaskStartEvent]
    onDidEndTask: Event[TaskEndEvent]
    onDidStartTaskProcess: Event[TaskProcessStartEvent]
    onDidEndTaskProcess: Event[TaskProcessEndEvent]

class FileType(IntEnum):
    Unknown = 0
    File = 1
    Directory = 2
    SymbolicLink = 64

class FilePermission(IntEnum):
    Readonly = 1


class FileStat(TypedDict, total=False):
    type: FileType
    ctime: float
    mtime: float
    size: float
    permissions: Optional[FilePermission]


class FileSystemError(Exception):

    def FileNotFound(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass

    def FileExists(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass

    def FileNotADirectory(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass

    def FileIsADirectory(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass

    def NoPermissions(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass

    def Unavailable(self, messageOrUri: Optional[Union[str, Uri]] = None) -> 'FileSystemError':
        pass

    code: str

class FileChangeType(IntEnum):
    Changed = 1
    Created = 2
    Deleted = 3


class FileChangeEvent(TypedDict, total=True):
    type: FileChangeType
    uri: Uri


class FileSystemProvider:
    class WatchOptions_0(TypedDict, total=True):
        recursive: bool
        excludes: List[str]
    class WriteFileOptions_0(TypedDict, total=True):
        create: bool
        overwrite: bool
    class DeleteOptions_0(TypedDict, total=True):
        recursive: bool
    class RenameOptions_0(TypedDict, total=True):
        overwrite: bool
    class CopyOptions_0(TypedDict, total=True):
        overwrite: bool
    onDidChangeFile: Event[List[FileChangeEvent]]

    def watch(self, uri: Uri, options: WatchOptions_0) -> Disposable:
        pass

    def stat(self, uri: Uri) -> Union[FileStat, Coroutine[FileStat]]:
        pass

    def readDirectory(self, uri: Uri) -> Union[List[Tuple[str, FileType]], Coroutine[List[Tuple[str, FileType]]]]:
        pass

    def createDirectory(self, uri: Uri) -> Union[None, Coroutine]:
        pass

    def readFile(self, uri: Uri) -> Union['Uint8Array', Coroutine['Uint8Array']]:
        pass

    def writeFile(self, uri: Uri, content: 'Uint8Array', options: WriteFileOptions_0) -> Union[None, Coroutine]:
        pass

    def delete(self, uri: Uri, options: DeleteOptions_0) -> Union[None, Coroutine]:
        pass

    def rename(self, oldUri: Uri, newUri: Uri, options: RenameOptions_0) -> Union[None, Coroutine]:
        pass

    def copy(self, source: Uri, destination: Uri, options: CopyOptions_0) -> Union[None, Coroutine]:
        pass


class FileSystem:
    class DeleteOptions_0(TypedDict, total=False):
        recursive: Optional[bool]
        useTrash: Optional[bool]
    class RenameOptions_0(TypedDict, total=False):
        overwrite: Optional[bool]
    class CopyOptions_0(TypedDict, total=False):
        overwrite: Optional[bool]

    def stat(self, uri: Uri) -> Coroutine[FileStat]:
        pass

    def readDirectory(self, uri: Uri) -> Coroutine[List[Tuple[str, FileType]]]:
        pass

    def createDirectory(self, uri: Uri) -> Coroutine:
        pass

    def readFile(self, uri: Uri) -> Coroutine['Uint8Array']:
        pass

    def writeFile(self, uri: Uri, content: 'Uint8Array') -> Coroutine:
        pass

    def delete(self, uri: Uri, options: Optional[DeleteOptions_0] = None) -> Coroutine:
        pass

    def rename(self, source: Uri, target: Uri, options: Optional[RenameOptions_0] = None) -> Coroutine:
        pass

    def copy(self, source: Uri, target: Uri, options: Optional[CopyOptions_0] = None) -> Coroutine:
        pass

    def isWritableFileSystem(self, scheme: str) -> Union[bool, None]:
        pass


class WebviewPortMapping(TypedDict, total=True):
    webviewPort: float
    extensionHostPort: float


class WebviewOptions(TypedDict, total=False):
    enableScripts: Optional[bool]
    enableForms: Optional[bool]
    enableCommandUris: Optional[bool]
    localResourceRoots: Optional[List[Uri]]
    portMapping: Optional[List[WebviewPortMapping]]


class Webview:
    options: WebviewOptions
    html: str
    onDidReceiveMessage: Event[Any]

    def postMessage(self, message: Any) -> Coroutine[bool]:
        pass

    def asWebviewUri(self, localResource: Uri) -> Uri:
        pass
    cspSource: str


class WebviewPanelOptions(TypedDict, total=False):
    enableFindWidget: Optional[bool]
    retainContextWhenHidden: Optional[bool]


class WebviewPanel:
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    viewType: str
    title: str
    iconPath: Union[Uri, IconPath_1, None]
    webview: Webview
    options: WebviewPanelOptions
    viewColumn: Union[ViewColumn, None]
    active: bool
    visible: bool
    onDidChangeViewState: Event['WebviewPanelOnDidChangeViewStateEvent']
    onDidDispose: Event

    def reveal(self, viewColumn: Optional[ViewColumn] = None, preserveFocus: Optional[bool] = None) -> None:
        pass

    def dispose(self) -> Any:
        pass


class WebviewPanelOnDidChangeViewStateEvent(TypedDict, total=True):
    webviewPanel: WebviewPanel

T = TypeVar('T')

class WebviewPanelSerializer(Generic[T]):

    def deserializeWebviewPanel(self, webviewPanel: WebviewPanel, state: T) -> Coroutine:
        pass


class WebviewView:
    viewType: str
    webview: Webview
    title: Optional[str]
    description: Optional[str]
    onDidDispose: Event
    visible: bool
    onDidChangeVisibility: Event

    def show(self, preserveFocus: Optional[bool] = None) -> None:
        pass

T = TypeVar('T')

class WebviewViewResolveContext(Generic[T], GenericTypedDict, total=True):
    state: Union[T, None]


class WebviewViewProvider:

    def resolveWebviewView(self, webviewView: WebviewView, context: WebviewViewResolveContext, token: CancellationToken) -> Union[Coroutine, None]:
        pass


class CustomTextEditorProvider:

    def resolveCustomTextEditor(self, document: TextDocument, webviewPanel: WebviewPanel, token: CancellationToken) -> Union[Coroutine, None]:
        pass


class CustomDocument:
    uri: Uri

    def dispose(self) -> None:
        pass

T = TypeVar('T')

class CustomDocumentEditEvent(Generic[T]):
    document: T

    def undo(self) -> Union[Coroutine, None]:
        pass

    def redo(self) -> Union[Coroutine, None]:
        pass
    label: Optional[str]

T = TypeVar('T')

class CustomDocumentContentChangeEvent(Generic[T], GenericTypedDict, total=True):
    document: T


class CustomDocumentBackup:
    id: str

    def delete(self) -> None:
        pass


class CustomDocumentBackupContext(TypedDict, total=True):
    destination: Uri


class CustomDocumentOpenContext(TypedDict, total=True):
    backupId: Union[str, None]
    untitledDocumentData: Union['Uint8Array', None]

T = TypeVar('T')

class CustomReadonlyEditorProvider(Generic[T]):

    def openCustomDocument(self, uri: Uri, openContext: CustomDocumentOpenContext, token: CancellationToken) -> Union[Coroutine[T], T]:
        pass

    def resolveCustomEditor(self, document: T, webviewPanel: WebviewPanel, token: CancellationToken) -> Union[Coroutine, None]:
        pass

T = TypeVar('T')

class CustomEditorProvider(CustomReadonlyEditorProvider[T], Generic[T]):
    onDidChangeCustomDocument: Union[Event[CustomDocumentEditEvent[T]], Event[CustomDocumentContentChangeEvent[T]]]

    def saveCustomDocument(self, document: T, cancellation: CancellationToken) -> Coroutine:
        pass

    def saveCustomDocumentAs(self, document: T, destination: Uri, cancellation: CancellationToken) -> Coroutine:
        pass

    def revertCustomDocument(self, document: T, cancellation: CancellationToken) -> Coroutine:
        pass

    def backupCustomDocument(self, document: T, context: CustomDocumentBackupContext, cancellation: CancellationToken) -> Coroutine[CustomDocumentBackup]:
        pass


class Clipboard:

    def readText(self) -> Coroutine[str]:
        pass

    def writeText(self, value: str) -> Coroutine:
        pass

class UIKind(IntEnum):
    Desktop = 1
    Web = 2

class env:
    appName: str
    appRoot: str
    appHost: str
    uriScheme: str
    language: str
    clipboard: Clipboard
    machineId: str
    sessionId: str
    isNewAppInstall: bool
    isTelemetryEnabled: bool
    onDidChangeTelemetryEnabled: Event[bool]
    remoteName: Union[str, None]
    shell: str
    uiKind: UIKind

    def openExternal(target: Uri) -> Coroutine[bool]:
        pass

    def asExternalUri(target: Uri) -> Coroutine[Uri]:
        pass

class commands:
    def registerCommand(command: str, callback: Callable[[...], Any], thisArg: Optional[Any] = None) -> Disposable:
        pass

    def registerTextEditorCommand(command: str, callback: Callable[[...], None], thisArg: Optional[Any] = None) -> Disposable:
        pass
    T = TypeVar('T')

    def executeCommand(command: str, *rest: Any) -> Coroutine[T]:
        pass

    def getCommands(filterInternal: Optional[bool] = None) -> Coroutine[List[str]]:
        pass


class WindowState(TypedDict, total=True):
    focused: bool


class UriHandler:

    def handleUri(self, uri: Uri) -> ProviderResult:
        pass

class window:
    activeTextEditor: Union[TextEditor, None]
    visibleTextEditors: List[TextEditor]
    onDidChangeActiveTextEditor: Event[Union[TextEditor, None]]
    onDidChangeVisibleTextEditors: Event[List[TextEditor]]
    onDidChangeTextEditorSelection: Event[TextEditorSelectionChangeEvent]
    onDidChangeTextEditorVisibleRanges: Event[TextEditorVisibleRangesChangeEvent]
    onDidChangeTextEditorOptions: Event[TextEditorOptionsChangeEvent]
    onDidChangeTextEditorViewColumn: Event[TextEditorViewColumnChangeEvent]
    terminals: List[Terminal]
    activeTerminal: Union[Terminal, None]
    onDidChangeActiveTerminal: Event[Union[Terminal, None]]
    onDidOpenTerminal: Event[Terminal]
    onDidCloseTerminal: Event[Terminal]
    onDidChangeTerminalState: Event[Terminal]
    state: WindowState
    onDidChangeWindowState: Event[WindowState]

    def showTextDocument(document: TextDocument, column: Optional[ViewColumn] = None, preserveFocus: Optional[bool] = None) -> Coroutine[TextEditor]:
        pass

    def showTextDocument(document: TextDocument, options: Optional[TextDocumentShowOptions] = None) -> Coroutine[TextEditor]:
        pass

    def showTextDocument(uri: Uri, options: Optional[TextDocumentShowOptions] = None) -> Coroutine[TextEditor]:
        pass

    def createTextEditorDecorationType(options: DecorationRenderOptions) -> TextEditorDecorationType:
        pass
    T = TypeVar('T')

    def showInformationMessage(message: str, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showInformationMessage(message: str, options: MessageOptions, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showInformationMessage(message: str, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showInformationMessage(message: str, options: MessageOptions, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showWarningMessage(message: str, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showWarningMessage(message: str, options: MessageOptions, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showWarningMessage(message: str, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showWarningMessage(message: str, options: MessageOptions, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showErrorMessage(message: str, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showErrorMessage(message: str, options: MessageOptions, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showErrorMessage(message: str, *items: T) -> Coroutine[Union[T, None]]:
        pass
    T = TypeVar('T')

    def showErrorMessage(message: str, options: MessageOptions, *items: T) -> Coroutine[Union[T, None]]:
        pass

    def showQuickPick(items: Union[List[str], Coroutine[List[str]]], options: Any, token: Optional[CancellationToken] = None) -> Coroutine[Union[List[str], None]]:
        pass

    def showQuickPick(items: Union[List[str], Coroutine[List[str]]], options: Optional[QuickPickOptions] = None, token: Optional[CancellationToken] = None) -> Coroutine[Union[str, None]]:
        pass
    T = TypeVar('T')

    def showQuickPick(items: Union[List[T], Coroutine[List[T]]], options: Any, token: Optional[CancellationToken] = None) -> Coroutine[Union[List[T], None]]:
        pass
    T = TypeVar('T')

    def showQuickPick(items: Union[List[T], Coroutine[List[T]]], options: Optional[QuickPickOptions] = None, token: Optional[CancellationToken] = None) -> Coroutine[Union[T, None]]:
        pass

    def showWorkspaceFolderPick(options: Optional[WorkspaceFolderPickOptions] = None) -> Coroutine[Union['WorkspaceFolder', None]]:
        pass

    def showOpenDialog(options: Optional[OpenDialogOptions] = None) -> Coroutine[Union[List[Uri], None]]:
        pass

    def showSaveDialog(options: Optional[SaveDialogOptions] = None) -> Coroutine[Union[Uri, None]]:
        pass

    def showInputBox(options: Optional[InputBoxOptions] = None, token: Optional[CancellationToken] = None) -> Coroutine[Union[str, None]]:
        pass
    T = TypeVar('T')

    def createQuickPick() -> 'QuickPick[T]':
        pass

    def createInputBox() -> 'InputBox':
        pass

    def createOutputChannel(name: str) -> OutputChannel:
        pass

    def createWebviewPanel(viewType: str, title: str, showOptions: Union[ViewColumn, CreateWebviewPanelShowOptions_1], options: Optional[Any] = None) -> WebviewPanel:
        pass

    def setStatusBarMessage(text: str, hideAfterTimeout: float) -> Disposable:
        pass

    def setStatusBarMessage(text: str, hideWhenDone: Coroutine[Any]) -> Disposable:
        pass

    def setStatusBarMessage(text: str) -> Disposable:
        pass
    R = TypeVar('R')

    def withScmProgress(task: Callable[[Progress[float]], Coroutine[R]]) -> Coroutine[R]:
        pass
    R = TypeVar('R')

    def withProgress(options: 'ProgressOptions', task: Callable[[Progress[WithProgressWithProgressProgress_0], CancellationToken], Coroutine[R]]) -> Coroutine[R]:
        pass

    def createStatusBarItem(alignment: Optional[StatusBarAlignment] = None, priority: Optional[float] = None) -> StatusBarItem:
        pass

    def createStatusBarItem(id: str, alignment: Optional[StatusBarAlignment] = None, priority: Optional[float] = None) -> StatusBarItem:
        pass

    def createTerminal(name: Optional[str] = None, shellPath: Optional[str] = None, shellArgs: Optional[Union[List[str], str]] = None) -> Terminal:
        pass

    def createTerminal(options: 'TerminalOptions') -> Terminal:
        pass

    def createTerminal(options: 'ExtensionTerminalOptions') -> Terminal:
        pass
    T = TypeVar('T')

    def registerTreeDataProvider(viewId: str, treeDataProvider: 'TreeDataProvider[T]') -> Disposable:
        pass
    T = TypeVar('T')

    def createTreeView(viewId: str, options: 'TreeViewOptions[T]') -> 'TreeView[T]':
        pass

    def registerUriHandler(handler: UriHandler) -> Disposable:
        pass

    def registerWebviewPanelSerializer(viewType: str, serializer: WebviewPanelSerializer) -> Disposable:
        pass

    def registerWebviewViewProvider(viewId: str, provider: WebviewViewProvider, options: Optional[RegisterWebviewViewProviderOptions_0] = None) -> Disposable:
        pass

    def registerCustomEditorProvider(viewType: str, provider: Union[CustomTextEditorProvider, CustomReadonlyEditorProvider, CustomEditorProvider], options: Optional[RegisterCustomEditorProviderOptions_0] = None) -> Disposable:
        pass

    def registerTerminalLinkProvider(provider: TerminalLinkProvider) -> Disposable:
        pass

    def registerTerminalProfileProvider(id: str, provider: TerminalProfileProvider) -> Disposable:
        pass

    def registerFileDecorationProvider(provider: FileDecorationProvider) -> Disposable:
        pass
    activeColorTheme: ColorTheme
    onDidChangeActiveColorTheme: Event[ColorTheme]

T = TypeVar('T')

class TreeViewOptions(Generic[T], GenericTypedDict, total=False):
    treeDataProvider: 'TreeDataProvider[T]'
    showCollapseAll: Optional[bool]
    canSelectMany: Optional[bool]

T = TypeVar('T')

class TreeViewExpansionEvent(Generic[T], GenericTypedDict, total=True):
    element: T

T = TypeVar('T')

class TreeViewSelectionChangeEvent(Generic[T], GenericTypedDict, total=True):
    selection: List[T]


class TreeViewVisibilityChangeEvent(TypedDict, total=True):
    visible: bool

T = TypeVar('T')

class TreeView(Disposable, Generic[T]):
    class RevealOptions_0(TypedDict, total=False):
        select: Optional[bool]
        focus: Optional[bool]
        expand: Union[bool, float, None]
    onDidExpandElement: Event[TreeViewExpansionEvent[T]]
    onDidCollapseElement: Event[TreeViewExpansionEvent[T]]
    selection: List[T]
    onDidChangeSelection: Event[TreeViewSelectionChangeEvent[T]]
    visible: bool
    onDidChangeVisibility: Event[TreeViewVisibilityChangeEvent]
    message: Optional[str]
    title: Optional[str]
    description: Optional[str]

    def reveal(self, element: T, options: Optional[RevealOptions_0] = None) -> Coroutine:
        pass

T = TypeVar('T')

class TreeDataProvider(Generic[T]):
    onDidChangeTreeData: Optional[Event[Union[T, None]]]

    def getTreeItem(self, element: T) -> Union['TreeItem', Coroutine['TreeItem']]:
        pass

    def getChildren(self, element: Optional[T] = None) -> ProviderResult[List[T]]:
        pass

    def getParent(self, element: T) -> ProviderResult[T]:
        pass

    def resolveTreeItem(self, item: 'TreeItem', element: T, token: CancellationToken) -> ProviderResult['TreeItem']:
        pass


class TreeItem:
    class IconPath_2(TypedDict, total=True):
        light: Union[str, Uri]
        dark: Union[str, Uri]
    label: Union[str, 'TreeItemLabel', None]
    id: Optional[str]
    iconPath: Union[str, Uri, IconPath_2, ThemeIcon, None]
    description: Union[str, bool, None]
    resourceUri: Optional[Uri]
    tooltip: Union[str, MarkdownString, None]
    command: Optional[Command]
    collapsibleState: Optional['TreeItemCollapsibleState']
    contextValue: Optional[str]
    accessibilityInformation: Optional[AccessibilityInformation]


class TreeItemCollapsibleState(IntEnum):
    None_ = 0
    Collapsed = 1
    Expanded = 2


class TreeItemLabel(TypedDict, total=False):
    label: str
    highlights: Optional[List[Tuple[float, float]]]


class TerminalOptions(TypedDict, total=False):
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    name: Optional[str]
    shellPath: Optional[str]
    shellArgs: Union[List[str], str, None]
    cwd: Union[str, Uri, None]
    env: Optional[Dict[str, Union[str, None]]]
    strictEnv: Optional[bool]
    hideFromUser: Optional[bool]
    message: Optional[str]
    iconPath: Union[Uri, IconPath_1, ThemeIcon, None]
    color: Optional[ThemeColor]
    location: Union[TerminalLocation, TerminalEditorLocationOptions, TerminalSplitLocationOptions, None]
    isTransient: Optional[bool]


class ExtensionTerminalOptions(TypedDict, total=False):
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    name: str
    pty: 'Pseudoterminal'
    iconPath: Union[Uri, IconPath_1, ThemeIcon, None]
    color: Optional[ThemeColor]
    location: Union[TerminalLocation, TerminalEditorLocationOptions, TerminalSplitLocationOptions, None]
    isTransient: Optional[bool]


class Pseudoterminal:
    onDidWrite: Event[str]
    onDidOverrideDimensions: Optional[Event[Union['TerminalDimensions', None]]]
    onDidClose: Optional[Event[Union[None, float]]]
    onDidChangeName: Optional[Event[str]]

    def open(self, initialDimensions: Union['TerminalDimensions', None]) -> None:
        pass

    def close(self) -> None:
        pass

    def handleInput(self, data: str) -> None:
        pass

    def setDimensions(self, dimensions: 'TerminalDimensions') -> None:
        pass


class TerminalDimensions(TypedDict, total=True):
    columns: float
    rows: float


class TerminalExitStatus(TypedDict, total=True):
    code: Union[float, None]

class EnvironmentVariableMutatorType(IntEnum):
    Replace = 1
    Append = 2
    Prepend = 3


class EnvironmentVariableMutator(TypedDict, total=True):
    type: EnvironmentVariableMutatorType
    value: str


class EnvironmentVariableCollection:
    persistent: bool

    def replace(self, variable: str, value: str) -> None:
        pass

    def append(self, variable: str, value: str) -> None:
        pass

    def prepend(self, variable: str, value: str) -> None:
        pass

    def get(self, variable: str) -> Union[EnvironmentVariableMutator, None]:
        pass

    def forEach(self, callback: Callable[[str, EnvironmentVariableMutator, 'EnvironmentVariableCollection'], Any], thisArg: Optional[Any] = None) -> None:
        pass

    def delete(self, variable: str) -> None:
        pass

    def clear(self) -> None:
        pass

class ProgressLocation(IntEnum):
    SourceControl = 1
    Window = 10
    Notification = 15


class ProgressOptions(TypedDict, total=False):
    class Location_1(TypedDict, total=True):
        viewId: str
    location: Union[ProgressLocation, Location_1]
    title: Optional[str]
    cancellable: Optional[bool]


class QuickInput:
    title: Union[str, None]
    step: Union[float, None]
    totalSteps: Union[float, None]
    enabled: bool
    busy: bool
    ignoreFocusOut: bool

    def show(self) -> None:
        pass

    def hide(self) -> None:
        pass
    onDidHide: Event

    def dispose(self) -> None:
        pass

T = TypeVar('T')

class QuickPick(QuickInput, Generic[T]):
    value: str
    placeholder: Union[str, None]
    onDidChangeValue: Event[str]
    onDidAccept: Event
    buttons: List['QuickInputButton']
    onDidTriggerButton: Event['QuickInputButton']
    onDidTriggerItemButton: Event['QuickPickItemButtonEvent[T]']
    items: List[T]
    canSelectMany: bool
    matchOnDescription: bool
    matchOnDetail: bool
    keepScrollPosition: Optional[bool]
    activeItems: List[T]
    onDidChangeActive: Event[List[T]]
    selectedItems: List[T]
    onDidChangeSelection: Event[List[T]]


class InputBox(QuickInput):
    value: str
    placeholder: Union[str, None]
    password: bool
    onDidChangeValue: Event[str]
    onDidAccept: Event
    buttons: List['QuickInputButton']
    onDidTriggerButton: Event['QuickInputButton']
    prompt: Union[str, None]
    validationMessage: Union[str, None]


class QuickInputButton(TypedDict, total=False):
    class IconPath_1(TypedDict, total=True):
        light: Uri
        dark: Uri
    iconPath: Union[Uri, IconPath_1, ThemeIcon]
    tooltip: Union[str, None]


class QuickInputButtons:
    Back: QuickInputButton
    private: Any


T = TypeVar('T')

class QuickPickItemButtonEvent(Generic[T], GenericTypedDict, total=True):
    button: QuickInputButton
    item: T


class TextDocumentContentChangeEvent(TypedDict, total=True):
    range: Range
    rangeOffset: float
    rangeLength: float
    text: str

class TextDocumentChangeReason(IntEnum):
    Undo = 1
    Redo = 2


class TextDocumentChangeEvent(TypedDict, total=True):
    document: TextDocument
    contentChanges: List[TextDocumentContentChangeEvent]
    reason: Union[TextDocumentChangeReason, None]

class TextDocumentSaveReason(IntEnum):
    Manual = 1
    AfterDelay = 2
    FocusOut = 3


class TextDocumentWillSaveEvent:
    document: TextDocument
    reason: TextDocumentSaveReason

    @singledispatchmethod
    def waitUntil(self, thenable: Coroutine[List[TextEdit]]) -> None:
        pass

    @waitUntil.register
    def _(self, thenable: Coroutine[Any]) -> None:
        pass


class FileWillCreateEvent:
    token: CancellationToken
    files: List[Uri]

    @singledispatchmethod
    def waitUntil(self, thenable: Coroutine[WorkspaceEdit]) -> None:
        pass

    @waitUntil.register
    def _(self, thenable: Coroutine[Any]) -> None:
        pass


class FileCreateEvent(TypedDict, total=True):
    files: List[Uri]


class FileWillDeleteEvent:
    token: CancellationToken
    files: List[Uri]

    @singledispatchmethod
    def waitUntil(self, thenable: Coroutine[WorkspaceEdit]) -> None:
        pass

    @waitUntil.register
    def _(self, thenable: Coroutine[Any]) -> None:
        pass


class FileDeleteEvent(TypedDict, total=True):
    files: List[Uri]


class FileWillRenameEvent:
    class Files_0(TypedDict, total=True):
        oldUri: Uri
        newUri: Uri
    token: CancellationToken
    files: List[Files_0]

    @singledispatchmethod
    def waitUntil(self, thenable: Coroutine[WorkspaceEdit]) -> None:
        pass

    @waitUntil.register
    def _(self, thenable: Coroutine[Any]) -> None:
        pass


class FileRenameEvent(TypedDict, total=True):
    class Files_0(TypedDict, total=True):
        oldUri: Uri
        newUri: Uri
    files: List[Files_0]


class WorkspaceFoldersChangeEvent(TypedDict, total=True):
    added: List['WorkspaceFolder']
    removed: List['WorkspaceFolder']


class WorkspaceFolder(TypedDict, total=True):
    uri: Uri
    name: str
    index: float

class workspace:
    fs: FileSystem
    rootPath: Union[str, None]
    workspaceFolders: Union[List[WorkspaceFolder], None]
    name: Union[str, None]
    workspaceFile: Union[Uri, None]
    onDidChangeWorkspaceFolders: Event[WorkspaceFoldersChangeEvent]

    def getWorkspaceFolder(uri: Uri) -> Union[WorkspaceFolder, None]:
        pass

    def asRelativePath(pathOrUri: Union[str, Uri], includeWorkspaceFolder: Optional[bool] = None) -> str:
        pass

    def updateWorkspaceFolders(start: float, deleteCount: Union[float, None], *workspaceFoldersToAdd: UpdateWorkspaceFoldersTOPLEVEL_0) -> bool:
        pass

    def createFileSystemWatcher(globPattern: GlobPattern, ignoreCreateEvents: Optional[bool] = None, ignoreChangeEvents: Optional[bool] = None, ignoreDeleteEvents: Optional[bool] = None) -> FileSystemWatcher:
        pass

    def findFiles(include: GlobPattern, exclude: Optional[Union[GlobPattern, None]] = None, maxResults: Optional[float] = None, token: Optional[CancellationToken] = None) -> Coroutine[List[Uri]]:
        pass

    def saveAll(includeUntitled: Optional[bool] = None) -> Coroutine[bool]:
        pass

    def applyEdit(edit: WorkspaceEdit) -> Coroutine[bool]:
        pass
    textDocuments: List[TextDocument]

    def openTextDocument(uri: Uri) -> Coroutine[TextDocument]:
        pass

    def openTextDocument(fileName: str) -> Coroutine[TextDocument]:
        pass

    def openTextDocument(options: Optional[OpenTextDocumentOptions_0] = None) -> Coroutine[TextDocument]:
        pass

    def registerTextDocumentContentProvider(scheme: str, provider: TextDocumentContentProvider) -> Disposable:
        pass
    onDidOpenTextDocument: Event[TextDocument]
    onDidCloseTextDocument: Event[TextDocument]
    onDidChangeTextDocument: Event[TextDocumentChangeEvent]
    onWillSaveTextDocument: Event[TextDocumentWillSaveEvent]
    onDidSaveTextDocument: Event[TextDocument]
    notebookDocuments: List['NotebookDocument']

    def openNotebookDocument(uri: Uri) -> Coroutine['NotebookDocument']:
        pass

    def openNotebookDocument(notebookType: str, content: Optional['NotebookData'] = None) -> Coroutine['NotebookDocument']:
        pass

    def registerNotebookSerializer(notebookType: str, serializer: 'NotebookSerializer', options: Optional['NotebookDocumentContentOptions'] = None) -> Disposable:
        pass
    onDidOpenNotebookDocument: Event['NotebookDocument']
    onDidCloseNotebookDocument: Event['NotebookDocument']
    onWillCreateFiles: Event[FileWillCreateEvent]
    onDidCreateFiles: Event[FileCreateEvent]
    onWillDeleteFiles: Event[FileWillDeleteEvent]
    onDidDeleteFiles: Event[FileDeleteEvent]
    onWillRenameFiles: Event[FileWillRenameEvent]
    onDidRenameFiles: Event[FileRenameEvent]

    def getConfiguration(section: Optional[str] = None, scope: Optional[Union['ConfigurationScope', None]] = None) -> WorkspaceConfiguration:
        pass
    onDidChangeConfiguration: Event['ConfigurationChangeEvent']

    def registerTaskProvider(type: str, provider: TaskProvider) -> Disposable:
        pass

    def registerFileSystemProvider(scheme: str, provider: FileSystemProvider, options: Optional[RegisterFileSystemProviderOptions_0] = None) -> Disposable:
        pass
    isTrusted: bool
    onDidGrantWorkspaceTrust: Event

class ConfigurationScope_3(TypedDict, total=False):
    uri: Optional[Uri]
    languageId: str
ConfigurationScope = Union[Uri, TextDocument, WorkspaceFolder, ConfigurationScope_3]


class ConfigurationChangeEvent:

    def affectsConfiguration(self, section: str, scope: Optional[ConfigurationScope] = None) -> bool:
        pass

class languages:
    def getLanguages() -> Coroutine[List[str]]:
        pass

    def setTextDocumentLanguage(document: TextDocument, languageId: str) -> Coroutine[TextDocument]:
        pass

    def match(selector: DocumentSelector, document: TextDocument) -> float:
        pass
    onDidChangeDiagnostics: Event[DiagnosticChangeEvent]

    def getDiagnostics(resource: Uri) -> List[Diagnostic]:
        pass

    def getDiagnostics() -> List[Tuple[Uri, List[Diagnostic]]]:
        pass

    def createDiagnosticCollection(name: Optional[str] = None) -> DiagnosticCollection:
        pass

    def createLanguageStatusItem(id: str, selector: DocumentSelector) -> LanguageStatusItem:
        pass

    def registerCompletionItemProvider(selector: DocumentSelector, provider: CompletionItemProvider, *triggerCharacters: str) -> Disposable:
        pass

    def registerCodeActionsProvider(selector: DocumentSelector, provider: CodeActionProvider, metadata: Optional[CodeActionProviderMetadata] = None) -> Disposable:
        pass

    def registerCodeLensProvider(selector: DocumentSelector, provider: CodeLensProvider) -> Disposable:
        pass

    def registerDefinitionProvider(selector: DocumentSelector, provider: DefinitionProvider) -> Disposable:
        pass

    def registerImplementationProvider(selector: DocumentSelector, provider: ImplementationProvider) -> Disposable:
        pass

    def registerTypeDefinitionProvider(selector: DocumentSelector, provider: TypeDefinitionProvider) -> Disposable:
        pass

    def registerDeclarationProvider(selector: DocumentSelector, provider: DeclarationProvider) -> Disposable:
        pass

    def registerHoverProvider(selector: DocumentSelector, provider: HoverProvider) -> Disposable:
        pass

    def registerEvaluatableExpressionProvider(selector: DocumentSelector, provider: EvaluatableExpressionProvider) -> Disposable:
        pass

    def registerInlineValuesProvider(selector: DocumentSelector, provider: InlineValuesProvider) -> Disposable:
        pass

    def registerDocumentHighlightProvider(selector: DocumentSelector, provider: DocumentHighlightProvider) -> Disposable:
        pass

    def registerDocumentSymbolProvider(selector: DocumentSelector, provider: DocumentSymbolProvider, metaData: Optional[DocumentSymbolProviderMetadata] = None) -> Disposable:
        pass

    def registerWorkspaceSymbolProvider(provider: WorkspaceSymbolProvider) -> Disposable:
        pass

    def registerReferenceProvider(selector: DocumentSelector, provider: ReferenceProvider) -> Disposable:
        pass

    def registerRenameProvider(selector: DocumentSelector, provider: RenameProvider) -> Disposable:
        pass

    def registerDocumentSemanticTokensProvider(selector: DocumentSelector, provider: DocumentSemanticTokensProvider, legend: SemanticTokensLegend) -> Disposable:
        pass

    def registerDocumentRangeSemanticTokensProvider(selector: DocumentSelector, provider: DocumentRangeSemanticTokensProvider, legend: SemanticTokensLegend) -> Disposable:
        pass

    def registerDocumentFormattingEditProvider(selector: DocumentSelector, provider: DocumentFormattingEditProvider) -> Disposable:
        pass

    def registerDocumentRangeFormattingEditProvider(selector: DocumentSelector, provider: DocumentRangeFormattingEditProvider) -> Disposable:
        pass

    def registerOnTypeFormattingEditProvider(selector: DocumentSelector, provider: OnTypeFormattingEditProvider, firstTriggerCharacter: str, *moreTriggerCharacter: str) -> Disposable:
        pass

    def registerSignatureHelpProvider(selector: DocumentSelector, provider: SignatureHelpProvider, *triggerCharacters: str) -> Disposable:
        pass

    def registerSignatureHelpProvider(selector: DocumentSelector, provider: SignatureHelpProvider, metadata: SignatureHelpProviderMetadata) -> Disposable:
        pass

    def registerDocumentLinkProvider(selector: DocumentSelector, provider: DocumentLinkProvider) -> Disposable:
        pass

    def registerColorProvider(selector: DocumentSelector, provider: DocumentColorProvider) -> Disposable:
        pass

    def registerInlayHintsProvider(selector: DocumentSelector, provider: InlayHintsProvider) -> Disposable:
        pass

    def registerFoldingRangeProvider(selector: DocumentSelector, provider: FoldingRangeProvider) -> Disposable:
        pass

    def registerSelectionRangeProvider(selector: DocumentSelector, provider: SelectionRangeProvider) -> Disposable:
        pass

    def registerCallHierarchyProvider(selector: DocumentSelector, provider: CallHierarchyProvider) -> Disposable:
        pass

    def registerTypeHierarchyProvider(selector: DocumentSelector, provider: TypeHierarchyProvider) -> Disposable:
        pass

    def registerLinkedEditingRangeProvider(selector: DocumentSelector, provider: LinkedEditingRangeProvider) -> Disposable:
        pass

    def setLanguageConfiguration(language: str, configuration: LanguageConfiguration) -> Disposable:
        pass

class NotebookCellKind(IntEnum):
    Markup = 1
    Code = 2


class NotebookCell(TypedDict, total=True):
    index: float
    notebook: 'NotebookDocument'
    kind: NotebookCellKind
    document: TextDocument
    metadata: Dict[str, Any]
    outputs: List['NotebookCellOutput']
    executionSummary: Union['NotebookCellExecutionSummary', None]


class NotebookEditor(TypedDict, total=True):
    pass


class NotebookRendererMessaging:
    class OnDidReceiveMessage_0(TypedDict, total=True):
        editor: NotebookEditor
        message: Any
    onDidReceiveMessage: Event[OnDidReceiveMessage_0]

    def postMessage(self, message: Any, editor: Optional[NotebookEditor] = None) -> Coroutine[bool]:
        pass


class NotebookDocument:
    uri: Uri
    notebookType: str
    version: float
    isDirty: bool
    isUntitled: bool
    isClosed: bool
    metadata: Dict[str, Any]
    cellCount: float

    def cellAt(self, index: float) -> NotebookCell:
        pass

    def getCells(self, range: Optional['NotebookRange'] = None) -> List[NotebookCell]:
        pass

    def save(self) -> Coroutine[bool]:
        pass


class NotebookCellExecutionSummary(TypedDict, total=False):
    class Timing_0(TypedDict, total=True):
        startTime: float
        endTime: float
    executionOrder: Optional[float]
    success: Optional[bool]
    timing: Optional[Timing_0]


class NotebookRange:
    class With_Change_0(TypedDict, total=False):
        start: Optional[float]
        end: Optional[float]
    start: float
    end: float
    isEmpty: bool


    def with_(self, change: With_Change_0) -> 'NotebookRange':
        pass


class NotebookCellOutputItem:

    def text(self, value: str, mime: Optional[str] = None) -> 'NotebookCellOutputItem':
        pass

    def json(self, value: Any, mime: Optional[str] = None) -> 'NotebookCellOutputItem':
        pass

    def stdout(self, value: str) -> 'NotebookCellOutputItem':
        pass

    def stderr(self, value: str) -> 'NotebookCellOutputItem':
        pass

    def error(self, value: Exception) -> 'NotebookCellOutputItem':
        pass
    mime: str
    data: 'Uint8Array'


class NotebookCellOutput:
    items: List[NotebookCellOutputItem]
    metadata: Optional[Dict[str, Any]]


class NotebookCellData:
    kind: NotebookCellKind
    value: str
    languageId: str
    outputs: Optional[List[NotebookCellOutput]]
    metadata: Optional[Dict[str, Any]]
    executionSummary: Optional[NotebookCellExecutionSummary]


class NotebookData:
    cells: List[NotebookCellData]
    metadata: Optional[Dict[str, Any]]


class NotebookSerializer:

    def deserializeNotebook(self, content: 'Uint8Array', token: CancellationToken) -> Union[NotebookData, Coroutine[NotebookData]]:
        pass

    def serializeNotebook(self, data: NotebookData, token: CancellationToken) -> Union['Uint8Array', Coroutine['Uint8Array']]:
        pass


class NotebookDocumentContentOptions(TypedDict, total=False):
    transientOutputs: Optional[bool]
    transientCellMetadata: Optional[Dict[str, Union[bool, None]]]
    transientDocumentMetadata: Optional[Dict[str, Union[bool, None]]]

class NotebookControllerAffinity(IntEnum):
    Default = 1
    Preferred = 2


class NotebookController:
    class CreateNotebookCellExecutionCreateNotebookCellExecutionOnDidChangeSelectedNotebooks_0(TypedDict, total=True):
        notebook: NotebookDocument
        selected: bool
    id: str
    notebookType: str
    supportedLanguages: Optional[List[str]]
    label: str
    description: Optional[str]
    detail: Optional[str]
    supportsExecutionOrder: Optional[bool]

    def createNotebookCellExecution(self, cell: NotebookCell) -> 'NotebookCellExecution':
        pass
    executeHandler: Callable[[List[NotebookCell], NotebookDocument, 'NotebookController'], Union[None, Coroutine]]
    interruptHandler: Optional[Callable[[NotebookDocument], Union[None, Coroutine]]]
    onDidChangeSelectedNotebooks: Event[CreateNotebookCellExecutionCreateNotebookCellExecutionOnDidChangeSelectedNotebooks_0]

    def updateNotebookAffinity(self, notebook: NotebookDocument, affinity: NotebookControllerAffinity) -> None:
        pass

    def dispose(self) -> None:
        pass


class NotebookCellExecution:
    cell: NotebookCell
    token: CancellationToken
    executionOrder: Union[float, None]

    def start(self, startTime: Optional[float] = None) -> None:
        pass

    def end(self, success: Union[bool, None], endTime: Optional[float] = None) -> None:
        pass

    def clearOutput(self, cell: Optional[NotebookCell] = None) -> Coroutine:
        pass

    def replaceOutput(self, out: Union[NotebookCellOutput, List[NotebookCellOutput]], cell: Optional[NotebookCell] = None) -> Coroutine:
        pass

    def appendOutput(self, out: Union[NotebookCellOutput, List[NotebookCellOutput]], cell: Optional[NotebookCell] = None) -> Coroutine:
        pass

    def replaceOutputItems(self, items: Union[NotebookCellOutputItem, List[NotebookCellOutputItem]], output: NotebookCellOutput) -> Coroutine:
        pass

    def appendOutputItems(self, items: Union[NotebookCellOutputItem, List[NotebookCellOutputItem]], output: NotebookCellOutput) -> Coroutine:
        pass

class NotebookCellStatusBarAlignment(IntEnum):
    Left = 1
    Right = 2


class NotebookCellStatusBarItem:
    text: str
    alignment: NotebookCellStatusBarAlignment
    command: Union[str, Command, None]
    tooltip: Optional[str]
    priority: Optional[float]
    accessibilityInformation: Optional[AccessibilityInformation]


class NotebookCellStatusBarItemProvider:
    onDidChangeCellStatusBarItems: Optional[Event]

    def provideCellStatusBarItems(self, cell: NotebookCell, token: CancellationToken) -> ProviderResult[Union[NotebookCellStatusBarItem, List[NotebookCellStatusBarItem]]]:
        pass

class notebooks:
    def createNotebookController(id: str, notebookType: str, label: str, handler: Optional[Callable[[List[NotebookCell], NotebookDocument, NotebookController], Union[None, Coroutine]]] = None) -> NotebookController:
        pass

    def registerNotebookCellStatusBarItemProvider(notebookType: str, provider: NotebookCellStatusBarItemProvider) -> Disposable:
        pass

    def createRendererMessaging(rendererId: str) -> NotebookRendererMessaging:
        pass


class SourceControlInputBox(TypedDict, total=True):
    value: str
    placeholder: str
    visible: bool


class QuickDiffProvider:

    def provideOriginalResource(self, uri: Uri, token: CancellationToken) -> ProviderResult[Uri]:
        pass


class SourceControlResourceThemableDecorations(TypedDict, total=False):
    iconPath: Union[str, Uri, ThemeIcon, None]


class SourceControlResourceDecorations(SourceControlResourceThemableDecorations, TypedDict, total=False):
    strikeThrough: Optional[bool]
    faded: Optional[bool]
    tooltip: Optional[str]
    light: Optional[SourceControlResourceThemableDecorations]
    dark: Optional[SourceControlResourceThemableDecorations]


class SourceControlResourceState(TypedDict, total=False):
    resourceUri: Uri
    command: Optional[Command]
    decorations: Optional[SourceControlResourceDecorations]
    contextValue: Optional[str]


class SourceControlResourceGroup:
    id: str
    label: str
    hideWhenEmpty: Optional[bool]
    resourceStates: List[SourceControlResourceState]

    def dispose(self) -> None:
        pass


class SourceControl:
    id: str
    label: str
    rootUri: Union[Uri, None]
    inputBox: SourceControlInputBox
    count: Optional[float]
    quickDiffProvider: Optional[QuickDiffProvider]
    commitTemplate: Optional[str]
    acceptInputCommand: Optional[Command]
    statusBarCommands: Optional[List[Command]]

    def createResourceGroup(self, id: str, label: str) -> SourceControlResourceGroup:
        pass

    def dispose(self) -> None:
        pass

class scm:
    inputBox: SourceControlInputBox

    def createSourceControl(id: str, label: str, rootUri: Optional[Uri] = None) -> SourceControl:
        pass


class DebugProtocolMessage(TypedDict, total=True):
    pass


class DebugProtocolSource(TypedDict, total=True):
    pass


class DebugProtocolBreakpoint(TypedDict, total=True):
    pass


class DebugConfiguration(TypedDict, total=True):
    type: str
    name: str
    request: str


class DebugSession:
    id: str
    type: str
    parentSession: Optional['DebugSession']
    name: str
    workspaceFolder: Union[WorkspaceFolder, None]
    configuration: DebugConfiguration

    def customRequest(self, command: str, args: Optional[Any] = None) -> Coroutine[Any]:
        pass

    def getDebugProtocolBreakpoint(self, breakpoint: 'Breakpoint') -> Coroutine[Union[DebugProtocolBreakpoint, None]]:
        pass


class DebugSessionCustomEvent(TypedDict, total=True):
    session: DebugSession
    event: str
    body: Any


class DebugConfigurationProvider:

    def provideDebugConfigurations(self, folder: Union[WorkspaceFolder, None], token: Optional[CancellationToken] = None) -> ProviderResult[List[DebugConfiguration]]:
        pass

    def resolveDebugConfiguration(self, folder: Union[WorkspaceFolder, None], debugConfiguration: DebugConfiguration, token: Optional[CancellationToken] = None) -> ProviderResult[DebugConfiguration]:
        pass

    def resolveDebugConfigurationWithSubstitutedVariables(self, folder: Union[WorkspaceFolder, None], debugConfiguration: DebugConfiguration, token: Optional[CancellationToken] = None) -> ProviderResult[DebugConfiguration]:
        pass


class DebugAdapterExecutable:

    command: str
    args: List[str]
    options: Optional['DebugAdapterExecutableOptions']


class DebugAdapterExecutableOptions(TypedDict, total=False):
    env: Optional[Dict[str, str]]
    cwd: Optional[str]


class DebugAdapterServer:
    port: float
    host: Union[str, None]


class DebugAdapterNamedPipeServer:
    path: str


class DebugAdapter(Disposable):
    onDidSendMessage: Event[DebugProtocolMessage]

    def handleMessage(self, message: DebugProtocolMessage) -> None:
        pass


class DebugAdapterInlineImplementation:
    pass

DebugAdapterDescriptor = Union[DebugAdapterExecutable, DebugAdapterServer, DebugAdapterNamedPipeServer, DebugAdapterInlineImplementation]


class DebugAdapterDescriptorFactory:

    def createDebugAdapterDescriptor(self, session: DebugSession, executable: Union[DebugAdapterExecutable, None]) -> ProviderResult[DebugAdapterDescriptor]:
        pass


class DebugAdapterTracker:

    def onWillStartSession(self) -> None:
        pass

    def onWillReceiveMessage(self, message: Any) -> None:
        pass

    def onDidSendMessage(self, message: Any) -> None:
        pass

    def onWillStopSession(self) -> None:
        pass

    def onError(self, error: Exception) -> None:
        pass

    def onExit(self, code: Union[float, None], signal: Union[str, None]) -> None:
        pass


class DebugAdapterTrackerFactory:

    def createDebugAdapterTracker(self, session: DebugSession) -> ProviderResult[DebugAdapterTracker]:
        pass


class DebugConsole:

    def append(self, value: str) -> None:
        pass

    def appendLine(self, value: str) -> None:
        pass


class BreakpointsChangeEvent(TypedDict, total=True):
    added: List['Breakpoint']
    removed: List['Breakpoint']
    changed: List['Breakpoint']


class Breakpoint:
    id: str
    enabled: bool
    condition: Union[str, None]
    hitCondition: Union[str, None]
    logMessage: Union[str, None]
    protected: Any


class SourceBreakpoint(Breakpoint):
    location: Location


class FunctionBreakpoint(Breakpoint):
    functionName: str


class DebugConsoleMode(IntEnum):
    Separate = 0
    MergeWithParent = 1


class DebugSessionOptions(TypedDict, total=False):
    parentSession: Optional[DebugSession]
    lifecycleManagedByParent: Optional[bool]
    consoleMode: Optional[DebugConsoleMode]
    noDebug: Optional[bool]
    compact: Optional[bool]

class DebugConfigurationProviderTriggerKind(IntEnum):
    Initial = 1
    Dynamic = 2

class debug:
    activeDebugSession: Union[DebugSession, None]
    activeDebugConsole: DebugConsole
    breakpoints: List[Breakpoint]
    onDidChangeActiveDebugSession: Event[Union[DebugSession, None]]
    onDidStartDebugSession: Event[DebugSession]
    onDidReceiveDebugSessionCustomEvent: Event[DebugSessionCustomEvent]
    onDidTerminateDebugSession: Event[DebugSession]
    onDidChangeBreakpoints: Event[BreakpointsChangeEvent]

    def registerDebugConfigurationProvider(debugType: str, provider: DebugConfigurationProvider, triggerKind: Optional[DebugConfigurationProviderTriggerKind] = None) -> Disposable:
        pass

    def registerDebugAdapterDescriptorFactory(debugType: str, factory: DebugAdapterDescriptorFactory) -> Disposable:
        pass

    def registerDebugAdapterTrackerFactory(debugType: str, factory: DebugAdapterTrackerFactory) -> Disposable:
        pass

    def startDebugging(folder: Union[WorkspaceFolder, None], nameOrConfiguration: Union[str, DebugConfiguration], parentSessionOrOptions: Optional[Union[DebugSession, DebugSessionOptions]] = None) -> Coroutine[bool]:
        pass

    def stopDebugging(session: Optional[DebugSession] = None) -> Coroutine:
        pass

    def addBreakpoints(breakpoints: List[Breakpoint]) -> None:
        pass

    def removeBreakpoints(breakpoints: List[Breakpoint]) -> None:
        pass

    def asDebugSourceUri(source: DebugProtocolSource, session: Optional[DebugSession] = None) -> Uri:
        pass

class extensions:
    T = TypeVar('T')

    def getExtension(extensionId: str) -> Union[Extension[T], None]:
        pass
    all: List[Extension[Any]]
    onDidChange: Event

class CommentThreadCollapsibleState(IntEnum):
    Collapsed = 0
    Expanded = 1

class CommentMode(IntEnum):
    Editing = 0
    Preview = 1


class CommentThread:
    uri: Uri
    range: Range
    comments: List['Comment']
    collapsibleState: CommentThreadCollapsibleState
    canReply: bool
    contextValue: Optional[str]
    label: Optional[str]

    def dispose(self) -> None:
        pass


class CommentAuthorInformation(TypedDict, total=False):
    name: str
    iconPath: Optional[Uri]


class CommentReaction(TypedDict, total=True):
    label: str
    iconPath: Union[str, Uri]
    count: float
    authorHasReacted: bool


class Comment(TypedDict, total=False):
    body: Union[str, MarkdownString]
    mode: CommentMode
    author: CommentAuthorInformation
    contextValue: Optional[str]
    reactions: Optional[List[CommentReaction]]
    label: Optional[str]
    timestamp: Optional['Date']


class CommentReply(TypedDict, total=True):
    thread: CommentThread
    text: str


class CommentingRangeProvider:

    def provideCommentingRanges(self, document: TextDocument, token: CancellationToken) -> ProviderResult[List[Range]]:
        pass


class CommentOptions(TypedDict, total=False):
    prompt: Optional[str]
    placeHolder: Optional[str]


class CommentController:
    id: str
    label: str
    options: Optional[CommentOptions]
    commentingRangeProvider: Optional[CommentingRangeProvider]

    def createCommentThread(self, uri: Uri, range: Range, comments: List[Comment]) -> CommentThread:
        pass
    reactionHandler: Optional[Callable[[Comment, CommentReaction], Coroutine]]

    def dispose(self) -> None:
        pass

class comments:
    def createCommentController(id: str, label: str) -> CommentController:
        pass


class AuthenticationSession(TypedDict, total=True):
    id: str
    accessToken: str
    account: 'AuthenticationSessionAccountInformation'
    scopes: List[str]


class AuthenticationSessionAccountInformation(TypedDict, total=True):
    id: str
    label: str


class AuthenticationGetSessionOptions(TypedDict, total=False):
    class ForceNewSession_1(TypedDict, total=True):
        detail: str
    clearSessionPreference: Optional[bool]
    createIfNone: Optional[bool]
    forceNewSession: Union[bool, ForceNewSession_1, None]
    silent: Optional[bool]


class AuthenticationProviderInformation(TypedDict, total=True):
    id: str
    label: str


class AuthenticationSessionsChangeEvent(TypedDict, total=True):
    provider: AuthenticationProviderInformation


class AuthenticationProviderOptions(TypedDict, total=False):
    supportsMultipleAccounts: Optional[bool]


class AuthenticationProviderAuthenticationSessionsChangeEvent(TypedDict, total=True):
    added: Union[List[AuthenticationSession], None]
    removed: Union[List[AuthenticationSession], None]
    changed: Union[List[AuthenticationSession], None]


class AuthenticationProvider:
    onDidChangeSessions: Event[AuthenticationProviderAuthenticationSessionsChangeEvent]

    def getSessions(self, scopes: Optional[List[str]] = None) -> Coroutine[List[AuthenticationSession]]:
        pass

    def createSession(self, scopes: List[str]) -> Coroutine[AuthenticationSession]:
        pass

    def removeSession(self, sessionId: str) -> Coroutine:
        pass

class authentication:
    def getSession(providerId: str, scopes: List[str], options: Any) -> Coroutine[AuthenticationSession]:
        pass

    def getSession(providerId: str, scopes: List[str], options: Any) -> Coroutine[AuthenticationSession]:
        pass

    def getSession(providerId: str, scopes: List[str], options: Optional[AuthenticationGetSessionOptions] = None) -> Coroutine[Union[AuthenticationSession, None]]:
        pass
    onDidChangeSessions: Event[AuthenticationSessionsChangeEvent]

    def registerAuthenticationProvider(id: str, label: str, provider: AuthenticationProvider, options: Optional[AuthenticationProviderOptions] = None) -> Disposable:
        pass

class tests:
    def createTestController(id: str, label: str) -> 'TestController':
        pass

class TestRunProfileKind(IntEnum):
    Run = 1
    Debug = 2
    Coverage = 3


class TestTag:
    id: str


class TestRunProfile:
    label: str
    kind: TestRunProfileKind
    isDefault: bool
    tag: Union[TestTag, None]
    configureHandler: Union[Callable[[], None], None]
    runHandler: Callable[['TestRunRequest', CancellationToken], Union[Coroutine, None]]

    def dispose(self) -> None:
        pass


class TestController:
    id: str
    label: str
    items: 'TestItemCollection'

    def createRunProfile(self, label: str, kind: TestRunProfileKind, runHandler: Callable[['TestRunRequest', CancellationToken], Union[Coroutine, None]], isDefault: Optional[bool] = None, tag: Optional[TestTag] = None) -> TestRunProfile:
        pass
    resolveHandler: Optional[Callable[[Union['TestItem', None]], Union[Coroutine, None]]]
    refreshHandler: Union[Callable[[CancellationToken], Union[Coroutine, None]], None]

    def createTestRun(self, request: 'TestRunRequest', name: Optional[str] = None, persist: Optional[bool] = None) -> 'TestRun':
        pass

    def createTestItem(self, id: str, label: str, uri: Optional[Uri] = None) -> 'TestItem':
        pass

    def dispose(self) -> None:
        pass


class TestRunRequest:
    include: Union[List['TestItem'], None]
    exclude: Union[List['TestItem'], None]
    profile: Union[TestRunProfile, None]


class TestRun:
    name: Union[str, None]
    token: CancellationToken
    isPersisted: bool

    def enqueued(self, test: 'TestItem') -> None:
        pass

    def started(self, test: 'TestItem') -> None:
        pass

    def skipped(self, test: 'TestItem') -> None:
        pass

    def failed(self, test: 'TestItem', message: Union['TestMessage', List['TestMessage']], duration: Optional[float] = None) -> None:
        pass

    def errored(self, test: 'TestItem', message: Union['TestMessage', List['TestMessage']], duration: Optional[float] = None) -> None:
        pass

    def passed(self, test: 'TestItem', duration: Optional[float] = None) -> None:
        pass

    def appendOutput(self, output: str, location: Optional[Location] = None, test: Optional['TestItem'] = None) -> None:
        pass

    def end(self) -> None:
        pass


class TestItemCollection:
    size: float

    def replace(self, items: List['TestItem']) -> None:
        pass

    def forEach(self, callback: Callable[['TestItem', 'TestItemCollection'], Any], thisArg: Optional[Any] = None) -> None:
        pass

    def add(self, item: 'TestItem') -> None:
        pass

    def delete(self, itemId: str) -> None:
        pass

    def get(self, itemId: str) -> Union['TestItem', None]:
        pass


class TestItem(TypedDict, total=False):
    id: str
    uri: Union[Uri, None]
    children: TestItemCollection
    parent: Union['TestItem', None]
    tags: List[TestTag]
    canResolveChildren: bool
    busy: bool
    label: str
    description: Optional[str]
    sortText: Union[str, None]
    range: Union[Range, None]
    error: Union[str, MarkdownString, None]


class TestMessage:
    message: Union[str, MarkdownString]
    expectedOutput: Optional[str]
    actualOutput: Optional[str]
    location: Optional[Location]

    def diff(self, message: Union[str, MarkdownString], expected: str, actual: str) -> 'TestMessage':
        pass


T = TypeVar('T')

class Thenable(Generic[T]):
    TResult = TypeVar('TResult')

    @singledispatchmethod
    def then(self, onfulfilled: Optional[Callable[[T], Union[TResult, Coroutine[TResult]]]] = None, onrejected: Optional[Callable[[Any], Union[TResult, Coroutine[TResult]]]] = None) -> Coroutine[TResult]:
        pass
    TResult = TypeVar('TResult')

    @then.register
    def _(self, onfulfilled: Optional[Callable[[T], Union[TResult, Coroutine[TResult]]]] = None, onrejected: Optional[Callable[[Any], None]] = None) -> Coroutine[TResult]:
        pass


##### END OF LSP SPECS
