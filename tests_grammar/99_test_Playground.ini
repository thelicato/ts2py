[match:declaration]
M1: """hoverMessage?: MarkdownString | MarkedString | Array<MarkdownString | MarkedString>"""

[match:function]
M2: """getWordRangeAtPosition(position: Position, regex?: RegExp): Range | undefined"""
M3: """set(entries: ReadonlyArray<[Uri, readonly Diagnostic[] | undefined]>): void"""

[match:interface]
M1: """export interface LanguageConfiguration {
		comments?: CommentRule;
		brackets?: CharacterPair[];
		wordPattern?: RegExp;
		indentationRules?: IndentationRule;
		onEnterRules?: OnEnterRule[];
		__electricCharacterSupport?: {
			brackets?: any;
			docComment?: {
				scope: string;
				open: string;
				lineStart: string;
				close?: string;
			};
		};
		__characterPairSupport?: {
			autoClosingPairs: {
				open: string;
				close: string;
				notIn?: string[];
			}[];
		};
	}"""
M2: """export interface NotebookController {
		readonly id: string;
		readonly notebookType: string;
		supportedLanguages?: string[];
		label: string;
		description?: string;
		detail?: string;
		supportsExecutionOrder?: boolean;
		createNotebookCellExecution(cell: NotebookCell): NotebookCellExecution;
		executeHandler: (cells: NotebookCell[], notebook: NotebookDocument, controller: NotebookController) => void | Thenable<void>;
		interruptHandler?: (notebook: NotebookDocument) => void | Thenable<void>;
		readonly onDidChangeSelectedNotebooks: Event<{ notebook: NotebookDocument; selected: boolean }>;
		updateNotebookAffinity(notebook: NotebookDocument, affinity: NotebookControllerAffinity): void;
		dispose(): void;
	}"""
M3:  """export interface CancellationToken {
		isCancellationRequested: boolean;
		onCancellationRequested: Event<any>;
	}"""
M4: """export class CancellationError extends Error {
		constructor();
	}"""
M5: """export interface FileSystemWatcher extends Disposable {
		ignoreCreateEvents: boolean;
		ignoreChangeEvents: boolean;
		ignoreDeleteEvents: boolean;
		onDidCreate: Event<Uri>;
		onDidChange: Event<Uri>;
		onDidDelete: Event<Uri>;
	}"""
M6: """export class Position {
		readonly line: number;
		readonly character: number;
		constructor(line: number, character: number);
		isBefore(other: Position): boolean;
		isBeforeOrEqual(other: Position): boolean;
		isAfter(other: Position): boolean;
		isAfterOrEqual(other: Position): boolean;
		isEqual(other: Position): boolean;
		compareTo(other: Position): number;
		translate(lineDelta?: number, characterDelta?: number): Position;
		translate(change: { lineDelta?: number; characterDelta?: number }): Position;
		with(line?: number, character?: number): Position;
		with(change: { line?: number; character?: number }): Position;
	}"""